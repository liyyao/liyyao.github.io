<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>“反范式”数据库设计之数据冗余架构设计与细节</title>
    <url>/2020/09/06/202009062343/</url>
    <content><![CDATA[<h2 id="一、解决什么问题？"><a href="#一、解决什么问题？" class="headerlink" title="一、解决什么问题？"></a>一、解决什么问题？</h2><blockquote>
<p>（1）数据量大<br>（2）需要水平切分<br>（3）一个schema上有多个字段的查询需求  </p>
<p>举例：订单业务<br>Order(oid, info_detail)<br>T(buyer_id, seller_id, oid)<br>数据量大了怎么办？一个表一个库是存不下的，这个时候往往需要进行水平切分。订单表很容易进行水平切分，根据订单id进行表切分，查询的时候可以根据订单id直接定位到它水平切分到哪个库或者哪个表里面。但是关系表怎么切分呢？有买家id、卖家id,如果通过买家id来水平切分，保证同一个买家id的数据在一个库里或一个表里，根据买家id可以定位到这个买家有多少个订单id，这里如果要用卖家id来查询的话，就需要遍历多个库了；反之如果用卖家id来进行分库分表，同一个卖家的订单关系在一个库或一个表里，此时如果用买家id来查询订单，也需要遍历多个库或多个表。所以不管用买家id还是卖家id来进行水平切分，都有另外一种业务是无法满足的，如果要满足就需要扫描多库，在库的数量非常多数据量非常大的时候，扫描多库的性能是非常非常的低。</p>
</blockquote>
<h2 id="二、如何解决？"><a href="#二、如何解决？" class="headerlink" title="二、如何解决？"></a>二、如何解决？</h2><blockquote>
<p> 如果用大学数据库学的范式来解决，几乎是无解的，所以在互联网的某些场景之下，只有逆范式或反范式来设计表结构，进行数据冗余才可以满足在多个业务场景下多个查询条件下的水平切分的需求。  </p>
<p> <strong>冗余表</strong><br> Order(oid, info_detail)<br> T1(buyer_id, seller_id, oid)<br> T2(seller_id, buyer_id, oid)  </p>
</blockquote>
<h2 id="三、如何冗余？"><a href="#三、如何冗余？" class="headerlink" title="三、如何冗余？"></a>三、如何冗余？</h2><blockquote>
<p><strong>（1）服务同步冗余</strong><br> 在进行表数据插入时，同时插入到T1,T2两张表中<br> 优点：1.不复杂; 2.不一致性概率低<br> 缺点：1.因为要插入两张表数据，处理业务时间增加； 2.仍然可能出现不一致</p>
<p><strong>（2）服务异步冗余</strong><br> 增加一个消息队列，当插入T1表后，向消息队列中发送一个消息，然后由另外一个服务将数据插入到T2表中<br> 优点：访问一次数据库，与不冗余数据时时间相同<br> 缺点：1.复杂度增加，增加一个MQ； 2.消息发送成功不等于T2插入成功，此时查询T2会查询不到数据，但这个时间比较短，业务上往往是可以接受的； 3.不在一个分布式事务里，会出现数据不一致性  </p>
<p><strong>（3）线下异步冗余</strong><br>  添加一个bin log，然后调用服务进行T2表的数据插入<br>  优点：两次写操作解耦<br>  缺点：1.有延时，可能在T2中查询不到数据； 2.会出现数据不一致性问题  </p>
</blockquote>
<h2 id="四、“原子性事务”，正向表和反向表谁先操作？"><a href="#四、“原子性事务”，正向表和反向表谁先操作？" class="headerlink" title="四、“原子性事务”，正向表和反向表谁先操作？"></a>四、“原子性事务”，正向表和反向表谁先操作？</h2><blockquote>
<p>如果原子性被破坏，不一致出现，谁先做对业务的影响较小，就谁先执行</p>
</blockquote>
<h2 id="五、如何保证一致性？"><a href="#五、如何保证一致性？" class="headerlink" title="五、如何保证一致性？"></a>五、如何保证一致性？</h2><blockquote>
<p>在大数据、高并发、延迟敏感的业务中，并不能实时保证一致性，而是尽可能的发现数据不一致性，然后保证最终一致性。</p>
</blockquote>
<h2 id="六、如何保证一致性？"><a href="#六、如何保证一致性？" class="headerlink" title="六、如何保证一致性？"></a>六、如何保证一致性？</h2><blockquote>
<p> <strong>（1）全量数据扫描</strong><br>写一个离线程序，定时每天检查一次T1和T2表中数据是否一致，不一致的话进行补偿，使数据一致<br>优点：解耦<br>缺点：每天都需要大量检测，已经检测过的数据会重复检测，需要耗费的时间长，会导致数据不一致性的时间长</p>
<p> <strong>（2）增量日志扫</strong><br>服务插入T1或T2表后向T1日志或T2日志中写一条日志数据，然后写一个离线的程序，对日志进行检测，发现不一致则进行补偿，使数据一致<br>优点：1.不会重复检测数据； 2.检测周期缩短； 3.线上影响比较低<br>缺点：时效性还是不高  </p>
<p><strong>（3）实时消息对检测</strong><br> 增加一个消息队列，插入T1成功后就向消息队列中发送一条消息，插入T2d成功后，就向消息队列中发送一条消息，根据经验，5秒内能收到2条消息，如果未收到消息，则检测数据库数据是否一致<br> 缺点：复杂度高  </p>
</blockquote>
]]></content>
      <categories>
        <category>架构师训练营</category>
        <category>爆发期</category>
      </categories>
  </entry>
  <entry>
    <title>Dubbo集成Nacos</title>
    <url>/2020/09/13/202009132040/</url>
    <content><![CDATA[<h3 id="deom框架"><a href="#deom框架" class="headerlink" title="deom框架"></a>deom框架</h3><blockquote>
<p>三个module,一个提供api，一个提供api的实现，一个调用方。工程结构如下图所示。<br><img src="/2020/09/13/202009132040/1.png" alt="工程结构">  </p>
</blockquote>
<h4 id="一、api"><a href="#一、api" class="headerlink" title="一、api"></a>一、api</h4><blockquote>
<p>提供接口API  </p>
<pre><code>public interface ServiceA &#123;
    String greet(String name);
&#125;</code></pre>
</blockquote>
<h4 id="二、服务提供方ServiceA"><a href="#二、服务提供方ServiceA" class="headerlink" title="二、服务提供方ServiceA"></a>二、服务提供方ServiceA</h4><blockquote>
<p><strong>（1）pom.xml配置</strong>  </p>
<pre><code>&lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
    &lt;spring-cloud.version&gt;Greenwich.SR2&lt;/spring-cloud.version&gt;
&lt;/properties&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter&lt;/artifactId&gt;
        &lt;version&gt;2.1.2.RELEASE&lt;/version&gt;
        &lt;exclusions&gt;
            &lt;exclusion&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-context&lt;/artifactId&gt;
            &lt;/exclusion&gt;
        &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-dubbo&lt;/artifactId&gt;
        &lt;version&gt;2.1.2.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.liyyao.demo&lt;/groupId&gt;
        &lt;artifactId&gt;demo-dubbo-nacos-api&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-alibaba-nacos-discovery&lt;/artifactId&gt;
        &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;
        &lt;exclusions&gt;
            &lt;exclusion&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-context&lt;/artifactId&gt;
            &lt;/exclusion&gt;
        &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-context&lt;/artifactId&gt;
        &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
            &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;
            &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;  </code></pre>
</blockquote>
<blockquote>
<p><strong>（2）application.properties配置</strong>  </p>
<pre><code>spring.application.name=demo-dubbo-nacos-ServiceA
dubbo.scan.base-packages=com.liyyao.demo.dubbo.nacos
dubbo.protocol.name=dubbo
dubbo.protocol.port=20880
dubbo.registry.address=spring-cloud://localhost
spring.cloud.nacos.discovery.server-addr=101.133.233.66:8848,101.133.175.55:8848,101.133.172.57:8848  </code></pre>
</blockquote>
<blockquote>
<p><strong>（3）api接口的实现</strong>  </p>
<pre><code>@Service(
        version = &quot;1.0.0&quot;,
        interfaceClass = ServiceA.class,
        cluster = &quot;failfast&quot;,
        loadbalance = &quot;roundrobin&quot;
)
public class ServiceAImpl implements ServiceA &#123;
    public String greet(String name) &#123;
        return &quot;hello, &quot; + name;
    &#125;
&#125;  </code></pre>
</blockquote>
<blockquote>
<p><strong>（4）启动类</strong>  </p>
<pre><code>@SpringBootApplication
public class Application &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;  </code></pre>
</blockquote>
<h4 id="三、服务消费方ServiceB"><a href="#三、服务消费方ServiceB" class="headerlink" title="三、服务消费方ServiceB"></a>三、服务消费方ServiceB</h4><blockquote>
<p><strong>（1）pom.xml配置</strong>  </p>
<pre><code>&lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter&lt;/artifactId&gt;
        &lt;version&gt;2.1.2.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-dubbo&lt;/artifactId&gt;
        &lt;version&gt;2.1.2.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.zhss.demo&lt;/groupId&gt;
        &lt;artifactId&gt;demo-dubbo-nacos-api&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-alibaba-nacos-discovery&lt;/artifactId&gt;
        &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;
        &lt;exclusions&gt;
            &lt;exclusion&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-context&lt;/artifactId&gt;
            &lt;/exclusion&gt;
        &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-context&lt;/artifactId&gt;
        &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
        &lt;artifactId&gt;httpclient&lt;/artifactId&gt;
        &lt;version&gt;4.5.5&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;  </code></pre>
</blockquote>
<blockquote>
<p><strong>（2）application.properties配置</strong>  </p>
<pre><code>spring.application.name=demo-dubbo-nacos-ServiceB
dubbo.cloud.subscribed-services=demo-dubbo-nacos-ServiceA
dubbo.scan.base-packages=com.liyyao.demo.dubbo.nacos
spring.cloud.nacos.discovery.server-addr=101.133.233.66:8848,101.133.175.55:8848,101.133.172.57:8848  </code></pre>
</blockquote>
<blockquote>
<p><strong>（3）服用ServiceA的方法</strong></p>
<pre><code>@RestController
public class TestController &#123;
    @Reference(version = &quot;1.0.0&quot;,
            interfaceClass = ServiceA.class,
            cluster = &quot;failfast&quot;)
    private ServiceA serviceA;

    @GetMapping(&quot;/greet&quot;)
    public String greet(String name) &#123;
        return serviceA.greet(name);
    &#125;
&#125;  </code></pre>
</blockquote>
<blockquote>
<p><strong>（4）启动类</strong></p>
<pre><code>@SpringBootApplication
public class Application &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;  </code></pre>
</blockquote>
<h4 id="四、测试"><a href="#四、测试" class="headerlink" title="四、测试"></a>四、测试</h4><blockquote>
<p>启动成功后，打开浏览器，输入localhost:8080/great?name=lee可访问成功（name的参数输入什么，页面中显示什么）如下图所示。<br><img src="/2020/09/13/202009132040/2.png" alt="测试结果"></p>
</blockquote>
]]></content>
      <categories>
        <category>SpringCloud</category>
        <category>dubbo</category>
      </categories>
  </entry>
  <entry>
    <title>转正小记</title>
    <url>/2020/10/10/202010102013/</url>
    <content><![CDATA[<p>&emsp;&emsp;距离4月7号入职已过半年，今天终于要转正了，虽然现在比较佛系，但还是开心一下，毕竟转正后每月工资又多了些，现在就这点儿出息了，哈哈。</p>
<p>&emsp;&emsp;今天下午，生平第一次当着十几个人的面演讲ppt，足足讲了40分钟，真是紧张的要死，全程只顾着讲自己的，完全没有节奏，就像小学生背课文一样，哗啦啦一下将准备的东西都倒出来，也管不上听众的感受，自己也是身不由己，从没锻炼过，还有公众讲话恐惧症，不颤音不断片已经够好的了，以后还是要多多锻炼。</p>
<p>&emsp;&emsp;今晚可以睡个好觉了，这两天快被这个转正演讲折磨死了，从开始写ppt就一直处于紧张状态，跟打仗备战似的，时不时的进行演练一遍，昨晚重新改ppt加内容再过一遍弄到了1点，躺床上还是翻来覆去睡不着的在想着哪个点要怎样讲，好不容易睡着了梦里还是在和ppt拧巴，早上6点多醒了满脑子都是演讲的内容，脑子里再过一遍，公交地铁上书也没心看，一直在脑海里演练演讲的内容，上班后工作也不在状态也还在一直想着下午要怎么讲，中午吃饭和小伙伴说话都紧张的话都说不利索，吃完饭回来午睡又担心的睡不着手心开始冒汗，下午努力投入到工作中转移注意力，终于在5点开场进行了演讲，第一次第一次，激动、紧张，虽然全都是平时一起工作的同事，大家都很熟悉了，但心理就是这样不设防的塌陷，讲完之后如释重负，没有感动的想哭，只是想手舞足蹈，听着小伙伴们的评论，都是一个劲的夸赞，突然感觉很幸福，觉得自己在这个团队中能将自己的心理问题给治愈，能完善自己的人格缺陷，真真是太好了。最后还是丁总看的透澈，就是自己经历的太少了，踩的坑太少了，而又太脸皮子太薄，以后要多跳坑，有坑就跳，扛过了这波，剩下的就都不是事了。</p>
<p>&emsp;&emsp;生活总要有点仪式感，相信今天过后，自己可以朝着自己的展望脚踏实地的奋斗~</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>互联网公司部署方案</title>
    <url>/2020/10/13/202010132040/</url>
    <content><![CDATA[<p>&emsp;&emsp;但凡项目发布，都要考虑两个问题，一个是<strong>验证</strong>，一个是<strong>回滚</strong>。</p>
<p>&emsp;&emsp;<strong>验证</strong>就是说，你怎么确定你这次部署成功了？一般来说，要观察每台机器启动后处理请求时的日志，日志是否正常，是否有报错，一般日志正常、没有报错，那么就算是启动成功了，有时候也会让QA/PM做一个线上验证。</p>
<p>&emsp;&emsp;那么万一发布失败了呢？此时就得<strong>回滚</strong>，因为不同的上线是不一样的，有时候你仅仅是对代码做一些微调，大多数时候是针对新需求有上线，加了新的代码/接口，有时候是架构重构，实现机制和技术架构都变了，所以回滚可能也不太一样，比如，如果你是加了一些新的接口，结果上线失败了，此时新接口没人访问，直接代码回滚到旧版本重新部署就行了；如果你是做技术架构升级，此时失败了，可能很多请求已经处理失败，数据丢失，严重的时候会导致公司丢失订单，或者是数据写入了但是都错了，此时可能会采用回滚代码，或者清洗错乱数据的方式来回滚，总之，针对你的发布，你要考虑到失败之后的回滚方案，回滚代码，就得用旧版本的代码，然后重新在各个机器上依次部署，就算是一次回滚了，至于丢失了数据没有，要不要清洗数据，这个看情况来定。</p>
<h3 id="（1）滚动发布"><a href="#（1）滚动发布" class="headerlink" title="（1）滚动发布"></a>（1）滚动发布</h3><p>&emsp;&emsp;这是最常见的部署模式，一般就是说一个服务/系统都会部署在多台服务器上，部署的时候手动依次进行部署。比如每台服务器上放一个tomcat，每台机器依次停机tomcat，然后把新的代码放进去，再重新启动tomcat，各个服务器都这样做，这就是一种滚动发布。</p>
<p>&emsp;&emsp;中小型公司都会做自动化部署，自动化部署用的比较多的就是jenkins，因为jenkins是支持持续集成和持续交付的，简单来说就是你每天都提交代码，他每天都自动跑测试确保代码集成没问题，然后可能隔几天就把一个生产可用的小版本交付到线上。jenkins可以自动在多台机器上部署你的服务/系统，过程其实也是类似的，只不过把手动改成自动罢了。</p>
<p>&emsp;&emsp;中大型公司，一般发布系统都是自己研发的，你在上面指定一个服务，指定一个git仓库的代码分支，然后指定一个环境，指定一批机器，发布系统自动到git仓库拉取代码到本地，编译打包，然后在你指定环境的机器上，依次停止当前运行的进程，然后依次重启你新代码的服务进行。</p>
<p>&emsp;&emsp;以上这些都是典型的滚动发布。滚动发布的话，风险还是比较大的，因为一旦你用了自动化的滚动发布，那么发布系统会自动把你的所有机器都部署新版本的代码，这个时候中间很有可能会出现问题，导致大规模的异常和损失，所以现在一般中大型公司，都不会贸然用滚动发布模式。</p>
<h3 id="（2）灰度发布"><a href="#（2）灰度发布" class="headerlink" title="（2）灰度发布"></a>（2）灰度发布</h3><p>&emsp;&emsp;灰度发布就是说，不要上线就滚动全部发布到所有机器，一般就是会部署在比如1台机器上，采用新版本，然后切比如10%的流量过去，观察那10%的流量在1台机器上运行一段时间，比如运行几天时间，观察日志、异常、数据是否一切正常，如果验证发现全部都正常，那么此时就可以全量发布了，全量发布的时候就是采用滚动发布那种模式。</p>
<p>&emsp;&emsp;这个好处就是说，你先用10%以内的小流量放到灰度新版本的那台服务器上验证一段时间，感觉没问题了，才会全量部署，这么操作，即使有问题，也就10%以内的请求出现问题，损失不会太大，如果你公司体量特别大，灰度也可以是1%，甚至0.1%的流量。</p>
<p>&emsp;&emsp;如果灰度的时候有问题，那么立刻把10%以内的小流量切过去请求老版本代码部署的机器，灰度版本的机器立马就没有流量请求了，这个回滚速度是极快的。</p>
<p>&emsp;&emsp;通常灰度验证过后，全量发布都不会有太大的问题，基本上再出问题概率就很小了，所以现在中大型互联网公司一般都是灰度发布模式。</p>
<h3 id="（3）蓝绿部署"><a href="#（3）蓝绿部署" class="headerlink" title="（3）蓝绿部署"></a>（3）蓝绿部署</h3><p>&emsp;&emsp;蓝绿部署就是说，你得同时准备两个集群，一个集群放新版本代码，一个集群放老版本代码，然后新版本代码的集群准备好了过后，直接线上流量切到新版本集群上，跑一段时间来验证，如果发现有问题，回滚就是立马把流量切回老版本集群，回滚是很快速的。如果新版本集群运行一段时间感觉没问题了，此时就可以把老版本集群给下线了。</p>
<p>&emsp;&emsp;<strong>那么为什么有灰度发布了还要用蓝绿部署呢？</strong><br>&emsp;&emsp;灰度发布过后，还是要全量部署的，但是有时候，如果涉及到一些新的架构方案，或者是新的接口，10%以内的小流量可能没有办法暴露出线上的高并发问题，所以灰度验证没问题，结果全量部署还是有小概率会失败，此时全量发布用滚动发布的方式，逐步部署过去，很快会引发大规模的失败，此时回滚是很慢的，因为要一台一台逐步回滚。所以说，一般针对那种改动不太大的小版本，比如加一个接口，修改一些代码，修复几个bug，类似这种整体变动不太大的情况，建议使用灰度发布，因为这种一般灰度验证没问题，全量部署也不会有问题。但是如果涉及到那种很大规模的架构重构或者架构升级，比如数据存储架构升级，或者是技术架构整体改造，或者是代码大规模重构，类似这种场景，最好是用蓝绿部署，也就是说，完全部署一个新的集群，然后把较大的流量切过去，比如先切10%，再切50%，最后切到100%，让新集群承载100%的流量跑一段时间。过程中一旦有问题，立马流量全部切回老集群，这个回滚速度比灰度发布的全量部署回滚要快多了，因为仅仅是切流量而已，不需要重新部署。</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
        <category>技巧</category>
      </categories>
  </entry>
  <entry>
    <title>闲言碎语</title>
    <url>/2020/10/18/202010181635/</url>
    <content><![CDATA[<p>&emsp;&emsp;又是一个百无聊赖的周末，同往常一样，蜷缩在狭小的房间里过着与世隔绝的生活。一天没有出门，不知今天的天气如何，是晴天、阴天还是下雨天，一扇摆设似的窗户可以捕捉到天井漏下的天色、迷路的微风和一些房间传出的嘈杂的声音，如此看来，这窗户也倒不是一无是处，至少使得房间不显得那么闷和绝望。</p>
<p>&emsp;&emsp;上午窝在被窝里看了《黄金时代》这部电影，之前刚听到这电影名时以为是王小波的《黄金时代》被拍成电影了，后来了解到是讲萧红的平生，当时也没去翻出来看看，昨天看了b站的一个up主讲《呼兰河传》，再次提及了该电影，今天便找来了看看。看完有点儿小压抑，民国四大才女之一的萧红一生也是如此坎坷，在思想陈旧落后保守的年代，萧红逃婚与表哥私奔导致与家庭绝决，被抛弃后又被之前订婚的未婚夫抛弃，然后遇到了生命中最重要的男人萧军，共患难撑过了一段难捱的时光，但最后还是永远的分手了，后嫁给了端木蕻良，赶上日本侵华，颠沛流离，又身患重病，更不幸的是又被医生误诊喉咙有瘤，各种糟糕的事情糅杂在一起加速了萧红的生命走向了终点，年仅31岁。之前看过两遍萧红的《呼兰河传》，喜欢她写的呼兰河小镇的一些琐事，那是描述她童年的回忆，当时没有去了解萧红的一生，只是觉得能写出这样文字的作家很有才，应该也是顺顺当当的，但真没想到是这样的，看了这部电影后再去回味《呼兰河传》，萧红应该是经历了这么多坎坷后对童年生活的怀念和当时那种美好安静生活的思念吧。电影一头爷爷对萧红说，快快长大，长大就好了，但回过头来看，真的是长大就都好了么？这个应该都有体会的吧。</p>
<p>&emsp;&emsp;下午整理了下屋子，买了两个收纳箱，把书重新规整了一下，衣服收拾了一下，屋子也都弄了下，但发现还是有点儿乱乱的不知所措，就先这样吧，过不了几天就又乱成一团了。收拾了下心情，纠结了好久终于卸载了b站，以前老借着要在上面看学习视频为由留着，发现学习没学习多少，倒刷小视频上瘾了，实在受不了了就卸载得了，要看视频用电脑看，还能防止在床上葛优躺。之前卸载了知乎，现在没有也不刷了，最多偶尔有想知道的问题在电脑上找一下，今天又卸载了b站，可以省出时间来真正的多看书学习了，还有计划和目标没有安排没有实现，现在正是时候了。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云nacos集群部署</title>
    <url>/2020/08/29/aliyun-nacos/</url>
    <content><![CDATA[<h2 id="1-准备4台linux服务器"><a href="#1-准备4台linux服务器" class="headerlink" title="1. 准备4台linux服务器"></a>1. 准备4台linux服务器</h2><ul>
<li>准备阿里云服务器4台，3台用做nacos集群，1台用做mysql数据库</li>
<li>配置阿里云服务器网络安全组，打开入网端口（8848）</li>
</ul>
<h2 id="2-安装mysql"><a href="#2-安装mysql" class="headerlink" title="2. 安装mysql"></a>2. 安装mysql</h2><h3 id="（1）下载并安装MySQL官方的Yum-Repository-Mysql版本-5-7-14"><a href="#（1）下载并安装MySQL官方的Yum-Repository-Mysql版本-5-7-14" class="headerlink" title="（1）下载并安装MySQL官方的Yum Repository, Mysql版本 5.7.14"></a>（1）下载并安装MySQL官方的Yum Repository, Mysql版本 5.7.14</h3><pre><code># wget -i -c https://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm
# yum -y install mysql57-community-release-el7-10.noarch.rpm</code></pre>
<h3 id="（2）安装MySQL-服务器"><a href="#（2）安装MySQL-服务器" class="headerlink" title="（2）安装MySQL 服务器"></a>（2）安装MySQL 服务器</h3><pre><code># yum -y install mysql-community-server</code></pre>
<h3 id="（3）MySQL数据库设置"><a href="#（3）MySQL数据库设置" class="headerlink" title="（3）MySQL数据库设置"></a>（3）MySQL数据库设置</h3><ul>
<li><p>首先启动MySQL  </p>
<blockquote>
<p> # systemctl start mysqld.service</p>
</blockquote>
</li>
<li><p>查看MySQL运行状态</p>
<blockquote>
<p> # systemctl status mysqld.service</p>
</blockquote>
</li>
<li><p>找root用户密码</p>
<blockquote>
<p> # grep “password” /var/log/mysqld.log</p>
</blockquote>
</li>
<li><p>进入数据库</p>
<blockquote>
<p> # mysql -uroot -p</p>
</blockquote>
</li>
<li><p>修改数据库密码</p>
<blockquote>
<p>mysql&gt; SET PASSWORD = PASSWORD(‘12345678’);<br>mysql&gt; ALTER USER ‘root’@’localhost’ PASSWORD EXPIRE NEVER;<br>mysql&gt; FLUSH PRIVILEGES;  </p>
</blockquote>
</li>
<li><p>如果提示密码不符合策略，做如下操作再设置密码  </p>
<blockquote>
<p>mysql&gt; set global validate_password_policy=0;<br>mysql&gt; set global validate_password_length=1;</p>
</blockquote>
</li>
<li><p>重新登录数据库，设置远程连接</p>
<blockquote>
<p>mysql&gt; use mysql;<br>mysql&gt; update user set host = ‘%’ where user = ‘root’;<br>mysql&gt; FLUSH PRIVILEGES;</p>
</blockquote>
</li>
<li><p>进行远程连接测试</p>
<blockquote>
<p>本地进行连接测试</p>
</blockquote>
</li>
<li><p>为firewalld添加开放端口</p>
<blockquote>
<p>添加mysql端口3306<br> # systemctl start firewalld<br> # firewall-cmd –zone=public –add-port=3306/tcp –permanent<br> # firewall-cmd –reload</p>
</blockquote>
</li>
<li><p>更改mysql语言</p>
<blockquote>
<p> 首先重新登录mysql,然后输入status,可以看到Server characterset: latinl，不是utf-8;<br> 出mysql, vi /etc/my.cnf新增下面代码<br> character-set-server=utf8<br> collation-server=utf8_general_ci<br> 保存成功后，重启mysql,然后输入status就会发现变化了</p>
</blockquote>
</li>
</ul>
<h2 id="3-安装Nacos"><a href="#3-安装Nacos" class="headerlink" title="3. 安装Nacos"></a>3. 安装Nacos</h2><h3 id="（1）准备3台服务器作nacos集群"><a href="#（1）准备3台服务器作nacos集群" class="headerlink" title="（1）准备3台服务器作nacos集群"></a>（1）准备3台服务器作nacos集群</h3><blockquote>
<p>配置hosts<br># vi /etc/hosts<br>配置本机的hostname到ip地址的映射</p>
</blockquote>
<h3 id="（2）安装JDK"><a href="#（2）安装JDK" class="headerlink" title="（2）安装JDK"></a>（2）安装JDK</h3><blockquote>
<p>到ORACLE官网下载linux版本的jdk:<a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html</a><br>上传jdk到三台服务器上，然后安装  # rpm -ivh jdk-8u131-linux-x64.rpm<br>配置jdk相关环境变量 # vi /etc/bashrc<br>export JAVA_HOME=/usr/java/jdk1.8.0_131<br>export PATH=$PATH:$JAVA_HOME/bin<br>source /etc/bashrc<br>测试jdc安装是否成功：java -version</p>
</blockquote>
<h3 id="（3）下载nacos-server-1-4版本的源码"><a href="#（3）下载nacos-server-1-4版本的源码" class="headerlink" title="（3）下载nacos-server-1.4版本的源码"></a>（3）下载nacos-server-1.4版本的源码</h3><pre><code># git clone https://github.com/alibaba/nacos.git
# cd nacos
# mvn -Prelease-nacos -Dmaven.test.skip=true clean install -U
# ls -al distribution/target/ 可以看到nacos-server-1.4.0-SNAPSHOT.tar.gz压缩包  </code></pre>
<h3 id="（4）-nacos上传到服务器上"><a href="#（4）-nacos上传到服务器上" class="headerlink" title="（4） nacos上传到服务器上"></a>（4） nacos上传到服务器上</h3><pre><code>win命令可以用 scp nacos-server-1.4.0-SNAPSHOT.tar.gz root@192.168.xxx.xxx:/usr/local/xxx 上传到三台服务器上</code></pre>
<h3 id="（5）配置nacos"><a href="#（5）配置nacos" class="headerlink" title="（5）配置nacos"></a>（5）配置nacos</h3><ul>
<li>解压nacos  <ul>
<li>进入到nacos/conf目录下，重命名 cluster.conf.example, 去掉 example: mv cluster.conf.example cluster.conf, 然后编辑cluster.conf文件，配置三台机器的地址和端口号，默认端口号是8848  </li>
<li>配置数据库    <blockquote>
<p>修改application.properties文件里面数据库配置<br>spring.datasource.platform=mysql<br>db.num=1<br>db.url.0=xx, 替换成mysql数据库端口号及数据库<br>db.user=xx<br>db.password=xx</p>
</blockquote>
</li>
<li>打开8848端口<blockquote>
<p>开启防火墙  # systemctl start firewalld<br>开放指定端口  # firewall-cmd –zone=public –add-port=8848/tcp –permanent<br>重启防火墙  # firewall-cmd –reload</p>
</blockquote>
</li>
</ul>
</li>
<li>mysql导入nacos相关数据库表  <ul>
<li>在下载的nacos源码里nacos\distribution\conf下有nacos-mysql.sql文件 </li>
</ul>
</li>
<li>启动<ul>
<li>分别进行三台机器的bin目录下，执行startup.sh，检查logs目录下的start.out启动日志</li>
<li>启动时如果startup.sh无法启动，可能是因为文件格式不对，需要修改文件格式  <blockquote>
<p> # vi startup.sh<br> :set fileformat=unix<br> :wq</p>
</blockquote>
</li>
</ul>
</li>
<li>访问nacos  <ul>
<li>在浏览器地址栏输入nacos集群中的一个ip地址，192.168.xxx.xxx:8848/nacos/index.html即可跳转到nacos登录页面，默认用户名和密码都是nacos，登录成功后可看到nacos相关信息。</li>
</ul>
</li>
</ul>
<h2 id="4-问题"><a href="#4-问题" class="headerlink" title="4. 问题"></a>4. 问题</h2><h3 id="（1）nacos启动时nacos-log中报xxxIP未加入到集群list中的异常"><a href="#（1）nacos启动时nacos-log中报xxxIP未加入到集群list中的异常" class="headerlink" title="（1）nacos启动时nacos.log中报xxxIP未加入到集群list中的异常"></a>（1）nacos启动时nacos.log中报xxxIP未加入到集群list中的异常</h3><ul>
<li>阿里云的实例有公有ip和私有ip，在nacos的cluster.conf配置文件中配置的是公有ip,但在启动时，nacos会将本机的私有ip自动加入到cluster.conf文件中，导致启动时报xxxIP未加入到集群list中的异常，虽然在页面上可以正常进入到nacos管理页面，但在做dubbo集成时，dubbo的服务调用方会注册不成功。</li>
<li>目前的解决办法<blockquote>
<p>修改nacos的启动文件，添加本地ip地址配置<br># vi startup.sh<br>找到 JVM Configuration 这部分, 在集群参数里增加 -Dnacos.server.ip=xx<br>JAVA_OPT=”${JAVA_OPT} -Dnacos.server.ip=xx.xx.xx.xx”</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
        <category>nacos</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu/优麒麟安装deepin-wine微信的方法</title>
    <url>/2020/08/30/linux-wechat/</url>
    <content><![CDATA[<h2 id="ubuntu-16-04及以上可用。"><a href="#ubuntu-16-04及以上可用。" class="headerlink" title="ubuntu 16.04及以上可用。"></a>ubuntu 16.04及以上可用。</h2><ul>
<li><p>32位支持</p>
<blockquote>
<p># sudo dpkg –add-architecture i386</p>
</blockquote>
</li>
<li><p>添加源</p>
<blockquote>
<p># sudo vim /etc/apt/sources.list<br># deb <a href="https://mirrors.aliyun.com/deepin/">https://mirrors.aliyun.com/deepin/</a> panda main contrib non-free<br># deb-src <a href="https://mirrors.aliyun.com/deepin/">https://mirrors.aliyun.com/deepin/</a> panda main contrib non-free<br># deb <a href="https://mirrors.aliyun.com/deepin/">https://mirrors.aliyun.com/deepin/</a> panda main contrib non-free  </p>
</blockquote>
</li>
<li><p>保存后为上面的源加入许可证</p>
<blockquote>
<p># wget <a href="https://mirrors.aliyun.com/deepin/project/deepin-keyring.gpg">https://mirrors.aliyun.com/deepin/project/deepin-keyring.gpg</a><br># gpg –import deepin-keyring.gpg<br># sudo gpg –export –armor 209088E7 | sudo apt-key add – sudo apt-key adv –keyserver keyserver.ubuntu.com –recv-keys425956BB3E31DF51 </p>
</blockquote>
</li>
<li><p>安装微信（2.6.8版本）</p>
<blockquote>
<p># sudo apt update<br># sudo apt install deepin.com.wechat</p>
</blockquote>
</li>
<li><p>更新微信方法</p>
<blockquote>
<p># mkdir /tmp/wechat<br># cd /tmp/wechat<br># wget <a href="https://dldir1.qq.com/weixin/Windows/WeChatSetup.exe">https://dldir1.qq.com/weixin/Windows/WeChatSetup.exe</a><br># env WINEPREFIX=~/.deepinwine/Deepin-WeChat deepin-wine WeChatSetup.exe</p>
</blockquote>
</li>
<li><p>PS：sudo apt-cache search XXX 使用这个命令可搜索软件安装，QQ，TIM，钉钉，迅雷等可自取。</p>
</li>
</ul>
<ul>
<li>转载自：<a href="http://www.360doc.com/content/20/0814/03/2793098_930227541.shtml">http://www.360doc.com/content/20/0814/03/2793098_930227541.shtml</a></li>
</ul>
]]></content>
      <categories>
        <category>技巧</category>
        <category>系统</category>
      </categories>
  </entry>
</search>
