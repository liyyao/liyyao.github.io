<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Centos7 虚拟机ip配置</title>
    <url>/202104200630.html</url>
    <content><![CDATA[<p>###1.查看主机ip地址及网关###<br>    # ifconfig  </p>
<p>###2.修改配置###<br>    在虚拟机中找到/etc/sysconfig/network-scripts/ifcfg-enp0s3文件并编辑<br>    TYPE=Ethernet<br>    BOOTPROTO=none<br>    DEFROUTE=yes<br>    IPV4_FAILURE_FATAL=no<br>    IPV6INI=yes<br>    IPV6_AUTOCONF=yes<br>    IPV6_DEFROUTE=yes<br>    IPV6_FAILURE_FATAL=no<br>    IPV6_ADDR_GEN_MODE=stable-privacy<br>    NAME=enp0s3<br>    UUID=xxxxxxx<br>    DEVICE=enp0s3<br>    ONBOOT=yes  </p>
<pre><code>IPADDR=192.168.xx.xx (和宿主主机同一网段)  
PREFIX=24  
GATEWAY=192.168.xx.xx  
DNS1=114.114.114.114  
DNS2=8.8.8.8  
IPV6_PEERDNS=yes  
IPV6_PEERROUTES=yes  </code></pre>
<h3 id="3-重启服务"><a href="#3-重启服务" class="headerlink" title="3.重启服务"></a>3.重启服务</h3><pre><code># service network restart  
查看ip地址命令：# ip add  </code></pre>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7 没有ifconfig命令解决办法</title>
    <url>/202108222111.html</url>
    <content><![CDATA[<p>ifconfig命令用来查看ip信息，Linux最小化安装是没有ifconfig的，以下演示如果安装ifconfig。</p>
<h5 id="1-输入ifconfig提示不存在"><a href="#1-输入ifconfig提示不存在" class="headerlink" title="1.输入ifconfig提示不存在"></a><strong>1.输入ifconfig提示不存在</strong></h5><p><img src="/202108222111/2021082201.png" alt="-bash: ifconfig: command not found">  </p>
<h5 id="2-先确认是否因为环境变量没有ifconfig导致的"><a href="#2-先确认是否因为环境变量没有ifconfig导致的" class="headerlink" title="2.先确认是否因为环境变量没有ifconfig导致的"></a>2.先确认是否因为环境变量没有ifconfig导致的</h5><p><img src="/202108222111/2021082202.png" alt="环境变量"><br>  表示系统没有安装ifconfig</p>
<h5 id="3-安装ifconfig"><a href="#3-安装ifconfig" class="headerlink" title="3.安装ifconfig"></a><strong>3.安装ifconfig</strong></h5><pre><code># yum install ifconfig  </code></pre>
<p><img src="/202108222111/2021082203.png" alt="安装ifconfig"> </p>
<h5 id="4-提示没有ifconfig安装包。再使用yum-search-ifconfig来搜索下ifconfig的相关"><a href="#4-提示没有ifconfig安装包。再使用yum-search-ifconfig来搜索下ifconfig的相关" class="headerlink" title="4.提示没有ifconfig安装包。再使用yum search ifconfig来搜索下ifconfig的相关"></a><strong>4.提示没有ifconfig安装包。再使用yum search ifconfig来搜索下ifconfig的相关</strong></h5><pre><code># yum search ifconfig  </code></pre>
<p><img src="/202108222111/2021082204.png" alt="查看ifconfig相关"> </p>
<h5 id="5-查看ifconfig匹配的是net-tools-x86-64包，安装net-tools-x86-64包"><a href="#5-查看ifconfig匹配的是net-tools-x86-64包，安装net-tools-x86-64包" class="headerlink" title="5.查看ifconfig匹配的是net-tools.x86_64包，安装net-tools.x86_64包"></a><strong>5.查看ifconfig匹配的是net-tools.x86_64包，安装net-tools.x86_64包</strong></h5><pre><code># yum install net-tools.x86_64 -y  </code></pre>
<p><img src="/202108222111/2021082205.png" alt="安装net-tools.x86_64"> </p>
<h5 id="6-输入ifconfig查看效果"><a href="#6-输入ifconfig查看效果" class="headerlink" title="6.输入ifconfig查看效果"></a><strong>6.输入ifconfig查看效果</strong></h5><pre><code># ifconfig</code></pre>
<p><img src="/202108222111/2021082206.png" alt="查看ip"> </p>
<h5 id="7-输入ip-addr也可以查询"><a href="#7-输入ip-addr也可以查询" class="headerlink" title="7.输入ip addr也可以查询"></a><strong>7.输入ip addr也可以查询</strong></h5><pre><code># ip addr</code></pre>
<p><img src="/202108222111/2021082207.png" alt="查看ip"> </p>
]]></content>
  </entry>
  <entry>
    <title>Centos7 防火墙配置</title>
    <url>/202108232023.html</url>
    <content><![CDATA[<h5 id="1-查看防火墙服务状态"><a href="#1-查看防火墙服务状态" class="headerlink" title="1.查看防火墙服务状态"></a>1.查看防火墙服务状态</h5><pre><code># systemctl status firewalld</code></pre>
<h5 id="2-查看防火墙状态"><a href="#2-查看防火墙状态" class="headerlink" title="2.查看防火墙状态"></a>2.查看防火墙状态</h5><pre><code># firewall-cmd --state</code></pre>
<h5 id="3-开启、重启、关闭防火墙服务"><a href="#3-开启、重启、关闭防火墙服务" class="headerlink" title="3.开启、重启、关闭防火墙服务"></a>3.开启、重启、关闭防火墙服务</h5><pre><code># 开启
# service firewalld start 或 # systemctl start firewalld.service
# 重启
# service firewalld restart
# 关闭
# service firewalld stop 或 # systemctl stop firewalld.service
# 关闭防火墙开机启动
# systemctl disable firewalld.service
# 开启防火墙开机启动
# systemctl enable firewalld.service</code></pre>
<h5 id="4-查看防火墙规则"><a href="#4-查看防火墙规则" class="headerlink" title="4.查看防火墙规则"></a>4.查看防火墙规则</h5><pre><code># firewall-cmd --list-all</code></pre>
<h5 id="5-查询、开放、关闭端口"><a href="#5-查询、开放、关闭端口" class="headerlink" title="5.查询、开放、关闭端口"></a>5.查询、开放、关闭端口</h5><pre><code># 查询端口是否开放
# firewall-cmd --query-port=8080/tcp
# 开放80端口
# firewall-cmd --permanent --add-port=80/tcp
# 移除端口
# firewall-cmd --permanent --remove-port=8080/tcp

#重启防火墙（修改配置后要重启防火墙）
# firewall-cmd --reload</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo集成Nacos</title>
    <url>/202009132041.html</url>
    <content><![CDATA[<h3 id="deom框架"><a href="#deom框架" class="headerlink" title="deom框架"></a>deom框架</h3><blockquote>
<p>三个module,一个提供api，一个提供api的实现，一个调用方。工程结构如下图所示。<br><img src="/202009132041/1.png" alt="工程结构"></p>
</blockquote>
<h4 id="一、api"><a href="#一、api" class="headerlink" title="一、api"></a>一、api</h4><blockquote>
<p>提供接口API  </p>
<pre><code>public interface ServiceA &#123;
    String greet(String name);
&#125;</code></pre>
</blockquote>
<h4 id="二、服务提供方ServiceA"><a href="#二、服务提供方ServiceA" class="headerlink" title="二、服务提供方ServiceA"></a>二、服务提供方ServiceA</h4><blockquote>
<p><strong>（1）pom.xml配置</strong>  </p>
<pre><code>&lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
    &lt;spring-cloud.version&gt;Greenwich.SR2&lt;/spring-cloud.version&gt;
&lt;/properties&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter&lt;/artifactId&gt;
        &lt;version&gt;2.1.2.RELEASE&lt;/version&gt;
        &lt;exclusions&gt;
            &lt;exclusion&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-context&lt;/artifactId&gt;
            &lt;/exclusion&gt;
        &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-dubbo&lt;/artifactId&gt;
        &lt;version&gt;2.1.2.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.liyyao.demo&lt;/groupId&gt;
        &lt;artifactId&gt;demo-dubbo-nacos-api&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-alibaba-nacos-discovery&lt;/artifactId&gt;
        &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;
        &lt;exclusions&gt;
            &lt;exclusion&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-context&lt;/artifactId&gt;
            &lt;/exclusion&gt;
        &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-context&lt;/artifactId&gt;
        &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
            &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;
            &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;  </code></pre>
</blockquote>
<blockquote>
<p><strong>（2）application.properties配置</strong>  </p>
<pre><code>spring.application.name=demo-dubbo-nacos-ServiceA
dubbo.scan.base-packages=com.liyyao.demo.dubbo.nacos
dubbo.protocol.name=dubbo
dubbo.protocol.port=20880
dubbo.registry.address=spring-cloud://localhost
spring.cloud.nacos.discovery.server-addr=101.133.233.66:8848,101.133.175.55:8848,101.133.172.57:8848  </code></pre>
</blockquote>
<blockquote>
<p><strong>（3）api接口的实现</strong>  </p>
<pre><code>@Service(
        version = &quot;1.0.0&quot;,
        interfaceClass = ServiceA.class,
        cluster = &quot;failfast&quot;,
        loadbalance = &quot;roundrobin&quot;
)
public class ServiceAImpl implements ServiceA &#123;
    public String greet(String name) &#123;
        return &quot;hello, &quot; + name;
    &#125;
&#125;  </code></pre>
</blockquote>
<blockquote>
<p><strong>（4）启动类</strong>  </p>
<pre><code>@SpringBootApplication
public class Application &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;  </code></pre>
</blockquote>
<h4 id="三、服务消费方ServiceB"><a href="#三、服务消费方ServiceB" class="headerlink" title="三、服务消费方ServiceB"></a>三、服务消费方ServiceB</h4><blockquote>
<p><strong>（1）pom.xml配置</strong>  </p>
<pre><code>&lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
&lt;/properties&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter&lt;/artifactId&gt;
        &lt;version&gt;2.1.2.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-dubbo&lt;/artifactId&gt;
        &lt;version&gt;2.1.2.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.zhss.demo&lt;/groupId&gt;
        &lt;artifactId&gt;demo-dubbo-nacos-api&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-alibaba-nacos-discovery&lt;/artifactId&gt;
        &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;
        &lt;exclusions&gt;
            &lt;exclusion&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-context&lt;/artifactId&gt;
            &lt;/exclusion&gt;
        &lt;/exclusions&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-context&lt;/artifactId&gt;
        &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
        &lt;artifactId&gt;httpclient&lt;/artifactId&gt;
        &lt;version&gt;4.5.5&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;  </code></pre>
</blockquote>
<blockquote>
<p><strong>（2）application.properties配置</strong>  </p>
<pre><code>spring.application.name=demo-dubbo-nacos-ServiceB
dubbo.cloud.subscribed-services=demo-dubbo-nacos-ServiceA
dubbo.scan.base-packages=com.liyyao.demo.dubbo.nacos
spring.cloud.nacos.discovery.server-addr=101.133.233.66:8848,101.133.175.55:8848,101.133.172.57:8848  </code></pre>
</blockquote>
<blockquote>
<p><strong>（3）服用ServiceA的方法</strong></p>
<pre><code>@RestController
public class TestController &#123;
    @Reference(version = &quot;1.0.0&quot;,
            interfaceClass = ServiceA.class,
            cluster = &quot;failfast&quot;)
    private ServiceA serviceA;

    @GetMapping(&quot;/greet&quot;)
    public String greet(String name) &#123;
        return serviceA.greet(name);
    &#125;
&#125;  </code></pre>
</blockquote>
<blockquote>
<p><strong>（4）启动类</strong></p>
<pre><code>@SpringBootApplication
public class Application &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;  </code></pre>
</blockquote>
<h4 id="四、测试"><a href="#四、测试" class="headerlink" title="四、测试"></a>四、测试</h4><blockquote>
<p>启动成功后，打开浏览器，输入localhost:8080/great?name=lee可访问成功（name的参数输入什么，页面中显示什么）如下图所示。<br><img src="/202009132041/2.png" alt="测试结果"></p>
</blockquote>
]]></content>
      <categories>
        <category>SpringCloud</category>
        <category>dubbo</category>
      </categories>
  </entry>
  <entry>
    <title>JVM笔记</title>
    <url>/202104232053.html</url>
    <content><![CDATA[<blockquote>
</blockquote>
<p>1.par new + cms 的GC，如何保证只做ygc，jvm参数如何配置？<br>答：首先上线系统后，要借助一些工具观察每秒钟会新增多少对象在新生代里，然后多长时间触发一次Minor GC，平均每次Minor GC之后会有多少对象存活，Survivor区是否可以放的下。这里的关键点就是必须让Survivor区放下，而且不能因为动态年龄判定规则直接升入老年代，然后只要Survivor区可以放下，那么下次Minor GC后还是存活这么多对象，依然可以在另外一块Survivor区放下，基本就不会有对象升入老年代。</p>
<hr>
<blockquote>
</blockquote>
<p>2.当老年代的可用内存空间小于新生代所有对象的总大小时，无论有没有空间分配担保，最坏的情况都是一次Minor GC + Full GC，那为什么还需要分配担保机制？直接Minor GC，之后再进行那三种判断不就行了，HandlePromotionFail的意义何在？<br>答：如果没有开启一个检查，此时可能提前Full GC，那么这样就太频繁了，如果经过检查机制，发现不需要Full GC就直接Minor GC；差别在于不需要频繁Full GC。  </p>
<hr>
<blockquote>
</blockquote>
<p>3.CMS垃圾回收器<br>  CMS在执行一次垃圾回收的过程一共分为4个阶段：<br>  <strong>1.初始标记</strong>： 这个阶段会让系统的工作线程全部停止，进入“Stop the World”状态，然后标记出来所有GC Roots直接引用的对象。虽说要造成“Stop the World”，但其实影响不大，因为他的速度很快，仅仅标记GC Roots直接引用的那些对象。<br>  <strong>2.并发标记：</strong> 这个阶段会让系统线程可以随意创建各种对象，继续运行，在运行期间可能会创建新的存活对象，也可能会让部分存活对象失去引用，变成垃圾对象，在这个过程中，垃圾回收线程，会尽可能的对已有的对象进行GC Roots追踪。这个阶段是对老年代所有对象进行GC Roots追踪，是最耗时的，他需要追踪所有对象是否从根源上被GC Roots引用了，但这个最耗时的阶段，是跟系统程序并发运行的，所以其实这个阶段不会对系统运行造成影响<br>  <strong>3.重新标记：</strong> 因为第二阶段结束后，会有很多存活对象和垃圾对象是之前第二阶段没标记出来的，所以此时进入第三阶段，继续让系统程序停下来，再次进入“Stop the World”阶段，然后重新标记下在第二阶段里新创建的一些对象，还有一些已有对象可能失去引用变成垃圾的情况。这个阶段速度很快的，他其实就是对在第二阶段中被系统程序运行变动过的少数对象进行标记，所以运行速度很快。<br>  <strong>4.并发清理：</strong> 这个阶段就是让系统程序随意运行，然后他来清理掉之前标记为垃圾的对象即可。这个阶段是很耗时的，因为需要进行对象的清理，但是他和系统程序并发运行的，所以其实也不影响系统程序的执行。<br>  <strong>CMS性能分析：</strong>第一和第三阶段虽然需要“STW”，但是这两个阶段都是简单的标记，速度非常快，基本上对系统运行响应也不大；第二和第四阶段是最耗时的，但都是和系统程序并发执行的，基本这两个最耗时的阶段对性能影响不大。  </p>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>SPI</title>
    <url>/202302041119.html</url>
    <content><![CDATA[<h1 id="1、什么是SPI？"><a href="#1、什么是SPI？" class="headerlink" title="1、什么是SPI？"></a>1、什么是SPI？</h1><p>​    <strong>SPI</strong>全称为Service Provider Interface，是一种服务发现机制。它通过在ClassPath路径下的META-INF/services文件夹查找文件，自动加载文件里所定义的类。这一机制为很多框架扩展提供了可能，比如现在的Dubbo、JDBC中都使用到了SPI机制。为什么要学SPI，因为在SpringBoot的自动装配中其实有使用到SPI机制，所以掌握了这部分对于SpringBoot的学习还是很有帮助的。</p>
<p>​    总结：SPI就是我定义接口，你去实现这些接口，然后在某个文件里告诉我实现是什么即可。</p>
<h1 id="2、案例"><a href="#2、案例" class="headerlink" title="2、案例"></a>2、案例</h1><p>​    我们Java在进行数据库连接时使用的JDBC，数据库的种类比较多，我们常用的就是MySQL和Oracle，如果没有一个访问数据库的统一接口，那么连接不同的数据库就需要写不同的程序，这样对程序员来说比较繁琐，而JDBC就提供了一些接口，定义了操作数据库的抽象行为，由各个数据库厂商自己实现。</p>
<h2 id="2-1-程序是怎么知道这些接口是由哪些Java类实现的呢？"><a href="#2-1-程序是怎么知道这些接口是由哪些Java类实现的呢？" class="headerlink" title="2.1 程序是怎么知道这些接口是由哪些Java类实现的呢？"></a>2.1 程序是怎么知道这些接口是由哪些Java类实现的呢？</h2><p>​    基于这个点，SPI定义了一个规范，实现者要在META-INF/services下创建接口名的文件，然后在文件中是接口的具体实现类。</p>
<h2 id="2-2-案例介绍"><a href="#2-2-案例介绍" class="headerlink" title="2.2 案例介绍"></a>2.2 案例介绍</h2><p>​    先定义接口项目</p>
<p><img src="/202302041119/SPI-01.png"></p>
<p>​    然后创建一个扩展的实现，先导入上面接口项目的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.liyyao<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>MyDataBase<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    然后创建接口的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SPI：MySQL对于getUrl的一种实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySqlConnection</span> <span class="keyword">implements</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;mysql...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    然后在resources目录下创建META-INF/services目录，然后在目录中创建一个文件，名称必须是定义的接口的全类路径名称。然后在文件中写上接口的实现类的全类路径名称。</p>
<p><img src="/202302041119/SPI-02.png"></p>
<p>同样的再创建一个扩展的实现</p>
<p><img src="/202302041119/SPI-03.png"></p>
<p>然后创建一个测试的项目，导入扩展的项目，然后进行测试，测试代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ServiceLoader&lt;Connection&gt; load = ServiceLoader.load(Connection.class);</span><br><span class="line">    Iterator&lt;Connection&gt; iterator = load.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Connection con = iterator.next();</span><br><span class="line">        con.getUrl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据不同的导入，执行的逻辑会有不同</p>
<p><img src="/202302041119/SPI-04.png"></p>
<p><img src="/202302041119/SPI-05.png"></p>
<h1 id="3、源码查看"><a href="#3、源码查看" class="headerlink" title="3、源码查看"></a>3、源码查看</h1><h2 id="3-1、ServiceLoader"><a href="#3-1、ServiceLoader" class="headerlink" title="3.1、ServiceLoader"></a>3.1、ServiceLoader</h2><p>​    首先来看下ServiceLoader的类结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置文件的路径</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">&quot;META-INF/services/&quot;</span>;</span><br><span class="line"><span class="comment">// 加载的服务 类或者接口</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; service;</span><br><span class="line"><span class="comment">// 类加载器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line"><span class="comment">// 访问权限的上下文对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line"><span class="comment">// 保存已经加载的服务类</span></span><br><span class="line"><span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 内部类，真正加载服务类</span></span><br><span class="line"><span class="keyword">private</span> LazyIterator lookupIterator;</span><br></pre></td></tr></table></figure>

<h2 id="3-2、load"><a href="#3-2、load" class="headerlink" title="3.2、load"></a>3.2、load</h2><p>​    load方法创建了一些属性，重要的是实例化了内部类，LazyIterator。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLoader</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ServiceLoader</span><span class="params">(Class&lt;S&gt; svc, ClassLoader cl)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//要加载的接口</span></span><br><span class="line">        service = Objects.requireNonNull(svc, <span class="string">&quot;Service interface cannot be null&quot;</span>);</span><br><span class="line">        <span class="comment">//类加载器</span></span><br><span class="line">        loader = (cl == <span class="keyword">null</span>) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">        <span class="comment">//访问控制器</span></span><br><span class="line">        acc = (System.getSecurityManager() != <span class="keyword">null</span>) ? AccessController.getContext():<span class="keyword">null</span>;</span><br><span class="line">        reload();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//先清空</span></span><br><span class="line">        providers.clear();</span><br><span class="line">        <span class="comment">//实例化内部类</span></span><br><span class="line">        lookupIterator = <span class="keyword">new</span> LazyIterator(service, loader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    查找实现类和创建实现类的过程，都在LazyIterator完成。当我们调用iterator.hasNext和iterator.next方法时，实际上调用的都是LazyIterator的相应方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">    Class&lt;S&gt; service;</span><br><span class="line">    ClassLoader loader;</span><br><span class="line">    Enumeration&lt;URL&gt; configs = <span class="keyword">null</span>;</span><br><span class="line">    Iterator&lt;String&gt; pending = <span class="keyword">null</span>;</span><br><span class="line">    String nextName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="comment">//META-INF/services/ 加上接口的全限定类名，就是文件服务类的文件</span></span><br><span class="line">            String fullName = PREFIX + service.getName();</span><br><span class="line">            <span class="comment">//将文件路径转成URL对象</span></span><br><span class="line">            configs = loader.getResources(fullName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">			<span class="comment">//解析URL文件对象，读取内容，最后返回</span></span><br><span class="line">       		pending = parse(service, configs.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拿到第一个实现类的类名</span></span><br><span class="line">        nextName = pending.next();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    创建实例对象，当然，调用next方法时，实际调用到的是lookupIterator.nextService。它通过反射的方式，创建实现类的实例并返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//全限定类名</span></span><br><span class="line">        String cn = nextName;</span><br><span class="line">        nextName = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//创建类的Class对象</span></span><br><span class="line">        Class&lt;?&gt; c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">        <span class="comment">//通过newInstance实例化</span></span><br><span class="line">        S p = service.cast(c.newInstance());</span><br><span class="line">        <span class="comment">//放入集合，返回实例</span></span><br><span class="line">        providers.put(cn, p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    看到这儿应该很清楚了，获取到类的实例，然后就可以做事情了。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云nacos集群部署</title>
    <url>/202008291036.html</url>
    <content><![CDATA[<h2 id="1-准备4台linux服务器"><a href="#1-准备4台linux服务器" class="headerlink" title="1. 准备4台linux服务器"></a>1. 准备4台linux服务器</h2><ul>
<li>准备阿里云服务器4台，3台用做nacos集群，1台用做mysql数据库</li>
<li>配置阿里云服务器网络安全组，打开入网端口（8848）</li>
</ul>
<h2 id="2-安装mysql"><a href="#2-安装mysql" class="headerlink" title="2. 安装mysql"></a>2. 安装mysql</h2><h3 id="（1）下载并安装MySQL官方的Yum-Repository-Mysql版本-5-7-14"><a href="#（1）下载并安装MySQL官方的Yum-Repository-Mysql版本-5-7-14" class="headerlink" title="（1）下载并安装MySQL官方的Yum Repository, Mysql版本 5.7.14"></a>（1）下载并安装MySQL官方的Yum Repository, Mysql版本 5.7.14</h3><pre><code># wget -i -c https://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm
# yum -y install mysql57-community-release-el7-10.noarch.rpm</code></pre>
<h3 id="（2）安装MySQL-服务器"><a href="#（2）安装MySQL-服务器" class="headerlink" title="（2）安装MySQL 服务器"></a>（2）安装MySQL 服务器</h3><pre><code># yum -y install mysql-community-server</code></pre>
<h3 id="（3）MySQL数据库设置"><a href="#（3）MySQL数据库设置" class="headerlink" title="（3）MySQL数据库设置"></a>（3）MySQL数据库设置</h3><ul>
<li><p>首先启动MySQL  </p>
<blockquote>
<p> # systemctl start mysqld.service</p>
</blockquote>
</li>
<li><p>查看MySQL运行状态</p>
<blockquote>
<p> # systemctl status mysqld.service</p>
</blockquote>
</li>
<li><p>找root用户密码</p>
<blockquote>
<p> # grep “password” /var/log/mysqld.log</p>
</blockquote>
</li>
<li><p>进入数据库</p>
<blockquote>
<p> # mysql -uroot -p</p>
</blockquote>
</li>
<li><p>修改数据库密码</p>
<blockquote>
<p>mysql&gt; SET PASSWORD = PASSWORD(‘12345678’);<br>mysql&gt; ALTER USER ‘root’@’localhost’ PASSWORD EXPIRE NEVER;<br>mysql&gt; FLUSH PRIVILEGES;  </p>
</blockquote>
</li>
<li><p>如果提示密码不符合策略，做如下操作再设置密码  </p>
<blockquote>
<p>mysql&gt; set global validate_password_policy=0;<br>mysql&gt; set global validate_password_length=1;</p>
</blockquote>
</li>
<li><p>重新登录数据库，设置远程连接</p>
<blockquote>
<p>mysql&gt; use mysql;<br>mysql&gt; update user set host = ‘%’ where user = ‘root’;<br>mysql&gt; FLUSH PRIVILEGES;</p>
</blockquote>
</li>
<li><p>进行远程连接测试</p>
<blockquote>
<p>本地进行连接测试</p>
</blockquote>
</li>
<li><p>为firewalld添加开放端口</p>
<blockquote>
<p>添加mysql端口3306<br> # systemctl start firewalld<br> # firewall-cmd –zone=public –add-port=3306/tcp –permanent<br> # firewall-cmd –reload</p>
</blockquote>
</li>
<li><p>更改mysql语言</p>
<blockquote>
<p> 首先重新登录mysql,然后输入status,可以看到Server characterset: latinl，不是utf-8;<br> 出mysql, vi /etc/my.cnf新增下面代码<br> character-set-server=utf8<br> collation-server=utf8_general_ci<br> 保存成功后，重启mysql,然后输入status就会发现变化了</p>
</blockquote>
</li>
</ul>
<h2 id="3-安装Nacos"><a href="#3-安装Nacos" class="headerlink" title="3. 安装Nacos"></a>3. 安装Nacos</h2><h3 id="（1）准备3台服务器作nacos集群"><a href="#（1）准备3台服务器作nacos集群" class="headerlink" title="（1）准备3台服务器作nacos集群"></a>（1）准备3台服务器作nacos集群</h3><blockquote>
<p>配置hosts<br># vi /etc/hosts<br>配置本机的hostname到ip地址的映射</p>
</blockquote>
<h3 id="（2）安装JDK"><a href="#（2）安装JDK" class="headerlink" title="（2）安装JDK"></a>（2）安装JDK</h3><blockquote>
<p>到ORACLE官网下载linux版本的jdk:<a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html</a><br>上传jdk到三台服务器上，然后安装  # rpm -ivh jdk-8u131-linux-x64.rpm<br>配置jdk相关环境变量 # vi /etc/bashrc<br>export JAVA_HOME=/usr/java/jdk1.8.0_131<br>export PATH=$PATH:$JAVA_HOME/bin<br>source /etc/bashrc<br>测试jdc安装是否成功：java -version</p>
</blockquote>
<h3 id="（3）下载nacos-server-1-4版本的源码"><a href="#（3）下载nacos-server-1-4版本的源码" class="headerlink" title="（3）下载nacos-server-1.4版本的源码"></a>（3）下载nacos-server-1.4版本的源码</h3><pre><code># git clone https://github.com/alibaba/nacos.git
# cd nacos
# mvn -Prelease-nacos -Dmaven.test.skip=true clean install -U
# ls -al distribution/target/ 可以看到nacos-server-1.4.0-SNAPSHOT.tar.gz压缩包  </code></pre>
<h3 id="（4）-nacos上传到服务器上"><a href="#（4）-nacos上传到服务器上" class="headerlink" title="（4） nacos上传到服务器上"></a>（4） nacos上传到服务器上</h3><pre><code>win命令可以用 scp nacos-server-1.4.0-SNAPSHOT.tar.gz root@192.168.xxx.xxx:/usr/local/xxx 上传到三台服务器上</code></pre>
<h3 id="（5）配置nacos"><a href="#（5）配置nacos" class="headerlink" title="（5）配置nacos"></a>（5）配置nacos</h3><ul>
<li>解压nacos  <ul>
<li>进入到nacos/conf目录下，重命名 cluster.conf.example, 去掉 example: mv cluster.conf.example cluster.conf, 然后编辑cluster.conf文件，配置三台机器的地址和端口号，默认端口号是8848  </li>
<li>配置数据库    <blockquote>
<p>修改application.properties文件里面数据库配置<br>spring.datasource.platform=mysql<br>db.num=1<br>db.url.0=xx, 替换成mysql数据库端口号及数据库<br>db.user=xx<br>db.password=xx</p>
</blockquote>
</li>
<li>打开8848端口<blockquote>
<p>开启防火墙  # systemctl start firewalld<br>开放指定端口  # firewall-cmd –zone=public –add-port=8848/tcp –permanent<br>重启防火墙  # firewall-cmd –reload</p>
</blockquote>
</li>
</ul>
</li>
<li>mysql导入nacos相关数据库表  <ul>
<li>在下载的nacos源码里nacos\distribution\conf下有nacos-mysql.sql文件 </li>
</ul>
</li>
<li>启动<ul>
<li>分别进行三台机器的bin目录下，执行startup.sh，检查logs目录下的start.out启动日志</li>
<li>启动时如果startup.sh无法启动，可能是因为文件格式不对，需要修改文件格式  <blockquote>
<p> # vi startup.sh<br> :set fileformat=unix<br> :wq</p>
</blockquote>
</li>
</ul>
</li>
<li>访问nacos  <ul>
<li>在浏览器地址栏输入nacos集群中的一个ip地址，192.168.xxx.xxx:8848/nacos/index.html即可跳转到nacos登录页面，默认用户名和密码都是nacos，登录成功后可看到nacos相关信息。</li>
</ul>
</li>
</ul>
<h2 id="4-问题"><a href="#4-问题" class="headerlink" title="4. 问题"></a>4. 问题</h2><h3 id="（1）nacos启动时nacos-log中报xxxIP未加入到集群list中的异常"><a href="#（1）nacos启动时nacos-log中报xxxIP未加入到集群list中的异常" class="headerlink" title="（1）nacos启动时nacos.log中报xxxIP未加入到集群list中的异常"></a>（1）nacos启动时nacos.log中报xxxIP未加入到集群list中的异常</h3><ul>
<li>阿里云的实例有公有ip和私有ip，在nacos的cluster.conf配置文件中配置的是公有ip,但在启动时，nacos会将本机的私有ip自动加入到cluster.conf文件中，导致启动时报xxxIP未加入到集群list中的异常，虽然在页面上可以正常进入到nacos管理页面，但在做dubbo集成时，dubbo的服务调用方会注册不成功。</li>
<li>目前的解决办法<blockquote>
<p>修改nacos的启动文件，添加本地ip地址配置<br># vi startup.sh<br>找到 JVM Configuration 这部分, 在集群参数里增加 -Dnacos.server.ip=xx<br>JAVA_OPT=”${JAVA_OPT} -Dnacos.server.ip=xx.xx.xx.xx”</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
        <category>nacos</category>
      </categories>
  </entry>
  <entry>
    <title>hexo 常用命令</title>
    <url>/202108221551.html</url>
    <content><![CDATA[<h3 id="1-hexo-init"><a href="#1-hexo-init" class="headerlink" title="1.hexo init"></a>1.hexo init</h3><pre><code>用于初始化本地文件夹为网站的根目录  
$ hexo init [folder]   
  folder 可选参数，用以指定初始化目录的路径，若无指定则默认为当前目录 </code></pre>
<h3 id="2-hexo-new"><a href="#2-hexo-new" class="headerlink" title="2.hexo new"></a>2.hexo new</h3><pre><code>命令用于新建文章，一般可以简写为 hexo n  
$ hexo new [layout] &lt;title&gt;  
  1.layout 可选参数，用以指定文章类型，若无指定则默认由配置文件中的 default_layout 选项决定
  2.title 必填参数，用以指定文章标题，如果参数值中含有空格，则需要使用双引号包围</code></pre>
<h3 id="3-hexo-generate"><a href="#3-hexo-generate" class="headerlink" title="3.hexo generate"></a>3.hexo generate</h3><pre><code>命令用于生成静态文件，一般可以简写为 hexo g  
$ hexo generate  
  -d 选项，指定生成后部署，与 hexo d -g 等价</code></pre>
<h3 id="4-hexo-server"><a href="#4-hexo-server" class="headerlink" title="4.hexo server"></a>4.hexo server</h3><pre><code>命令用于启动本地服务器，一般可以简写为 hexo s  
$ hexo server  
  1.-p 选项，指定服务器端口，默认为 4000
  2.-i 选项，指定服务器 IP 地址，默认为 0.0.0.0
  3.-s 选项，静态模式 ，仅提供 public 文件夹中的文件并禁用文件监视  
  说明 ：运行服务器前需要安装 hexo-server 插件 $ npm install hexo-server --save 
  详细信息请参考：[https://hexo.io/docs/server.html](https://hexo.io/docs/server.html)</code></pre>
<h3 id="5-hexo-deploy"><a href="#5-hexo-deploy" class="headerlink" title="5.hexo deploy"></a>5.hexo deploy</h3><pre><code>命令用于部署网站，一般可以简写为 hexo d  
$ hexo deploy  
  -g 选项，指定生成后部署，与 hexo g -d 等价</code></pre>
<h3 id="6-hexo-clean"><a href="#6-hexo-clean" class="headerlink" title="6.hexo clean"></a>6.hexo clean</h3><pre><code>命令用于清理缓存文件，是一个比较常用的命令  
$ hexo clean  
  网站显示异常时可尝试此操作</code></pre>
]]></content>
  </entry>
  <entry>
    <title>Ubuntu/优麒麟安装deepin-wine微信的方法</title>
    <url>/202008302202.html</url>
    <content><![CDATA[<h2 id="ubuntu-16-04及以上可用。"><a href="#ubuntu-16-04及以上可用。" class="headerlink" title="ubuntu 16.04及以上可用。"></a>ubuntu 16.04及以上可用。</h2><ul>
<li><p>32位支持</p>
<blockquote>
<p># sudo dpkg –add-architecture i386</p>
</blockquote>
</li>
<li><p>添加源</p>
<blockquote>
<p># sudo vim /etc/apt/sources.list<br># deb <a href="https://mirrors.aliyun.com/deepin/">https://mirrors.aliyun.com/deepin/</a> panda main contrib non-free<br># deb-src <a href="https://mirrors.aliyun.com/deepin/">https://mirrors.aliyun.com/deepin/</a> panda main contrib non-free<br># deb <a href="https://mirrors.aliyun.com/deepin/">https://mirrors.aliyun.com/deepin/</a> panda main contrib non-free  </p>
</blockquote>
</li>
<li><p>保存后为上面的源加入许可证</p>
<blockquote>
<p># wget <a href="https://mirrors.aliyun.com/deepin/project/deepin-keyring.gpg">https://mirrors.aliyun.com/deepin/project/deepin-keyring.gpg</a><br># gpg –import deepin-keyring.gpg<br># sudo gpg –export –armor 209088E7 | sudo apt-key add – sudo apt-key adv –keyserver keyserver.ubuntu.com –recv-keys425956BB3E31DF51 </p>
</blockquote>
</li>
<li><p>安装微信（2.6.8版本）</p>
<blockquote>
<p># sudo apt update<br># sudo apt install deepin.com.wechat</p>
</blockquote>
</li>
<li><p>更新微信方法</p>
<blockquote>
<p># mkdir /tmp/wechat<br># cd /tmp/wechat<br># wget <a href="https://dldir1.qq.com/weixin/Windows/WeChatSetup.exe">https://dldir1.qq.com/weixin/Windows/WeChatSetup.exe</a><br># env WINEPREFIX=~/.deepinwine/Deepin-WeChat deepin-wine WeChatSetup.exe</p>
</blockquote>
</li>
<li><p>PS：sudo apt-cache search XXX 使用这个命令可搜索软件安装，QQ，TIM，钉钉，迅雷等可自取。</p>
</li>
</ul>
<ul>
<li>转载自：<a href="http://www.360doc.com/content/20/0814/03/2793098_930227541.shtml">http://www.360doc.com/content/20/0814/03/2793098_930227541.shtml</a></li>
</ul>
]]></content>
      <categories>
        <category>技巧</category>
        <category>系统</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/202108162129.html</url>
    <content><![CDATA[<p>seata</p>
<p>下载地址：<a href="http://seata.io/zh-cn/blog/download.html">http://seata.io/zh-cn/blog/download.html</a><br>在seata官网，下载对应的版本安装包，binary的seata-server-xx.zip,然后scp上传到机器上，unzip命令解压。</p>
<p>yum -y install unzip</p>
<p>seata server 要存储很多数据，两种模式，一个是file，一个是db，建议用file，因为db的性能有点差，默认就是file模式的：sh -seata-server.sh -p 8901 -h 192.168.31.155 -m file,如果要用db模式，参考官网，还得先建一大堆表</p>
<p>registry.conf:就是seata server注册到比如nacos去，作为一个服务，然后你各个服务就不用手动配置seata server地址了，直接发现就可以了，不过不用这个手动配置其实也行。</p>
<p>file.conf，是seata server的配置信息，他还可以支持集成nacos配置中心，把配置放到nacos里去，然后seata server自动加载配置，一般你不用也可以。</p>
<p>正常启动，会要求1GB内存，如果不够的话，可以修改启动文件里的内存分配（seata-sever.sh 找-XX:MaxDirectMemorySize）。</p>
<p>nohup sh seata-server.sh -p 8901 -h 192.168.31.155 -m file &gt; /dev/null 2&gt;&amp;1 &amp;</p>
]]></content>
  </entry>
  <entry>
    <title>“反范式”数据库设计之数据冗余架构设计与细节</title>
    <url>/202009062154.html</url>
    <content><![CDATA[<h2 id="一、解决什么问题？"><a href="#一、解决什么问题？" class="headerlink" title="一、解决什么问题？"></a>一、解决什么问题？</h2><blockquote>
<p>（1）数据量大<br>（2）需要水平切分<br>（3）一个schema上有多个字段的查询需求  </p>
<p>举例：订单业务<br>Order(oid, info_detail)<br>T(buyer_id, seller_id, oid)<br>数据量大了怎么办？一个表一个库是存不下的，这个时候往往需要进行水平切分。订单表很容易进行水平切分，根据订单id进行表切分，查询的时候可以根据订单id直接定位到它水平切分到哪个库或者哪个表里面。但是关系表怎么切分呢？有买家id、卖家id,如果通过买家id来水平切分，保证同一个买家id的数据在一个库里或一个表里，根据买家id可以定位到这个买家有多少个订单id，这里如果要用卖家id来查询的话，就需要遍历多个库了；反之如果用卖家id来进行分库分表，同一个卖家的订单关系在一个库或一个表里，此时如果用买家id来查询订单，也需要遍历多个库或多个表。所以不管用买家id还是卖家id来进行水平切分，都有另外一种业务是无法满足的，如果要满足就需要扫描多库，在库的数量非常多数据量非常大的时候，扫描多库的性能是非常非常的低。</p>
</blockquote>
<h2 id="二、如何解决？"><a href="#二、如何解决？" class="headerlink" title="二、如何解决？"></a>二、如何解决？</h2><blockquote>
<p> 如果用大学数据库学的范式来解决，几乎是无解的，所以在互联网的某些场景之下，只有逆范式或反范式来设计表结构，进行数据冗余才可以满足在多个业务场景下多个查询条件下的水平切分的需求。  </p>
<p> <strong>冗余表</strong><br> Order(oid, info_detail)<br> T1(buyer_id, seller_id, oid)<br> T2(seller_id, buyer_id, oid)  </p>
</blockquote>
<h2 id="三、如何冗余？"><a href="#三、如何冗余？" class="headerlink" title="三、如何冗余？"></a>三、如何冗余？</h2><blockquote>
<p><strong>（1）服务同步冗余</strong><br> 在进行表数据插入时，同时插入到T1,T2两张表中<br> 优点：1.不复杂; 2.不一致性概率低<br> 缺点：1.因为要插入两张表数据，处理业务时间增加； 2.仍然可能出现不一致</p>
<p><strong>（2）服务异步冗余</strong><br> 增加一个消息队列，当插入T1表后，向消息队列中发送一个消息，然后由另外一个服务将数据插入到T2表中<br> 优点：访问一次数据库，与不冗余数据时时间相同<br> 缺点：1.复杂度增加，增加一个MQ； 2.消息发送成功不等于T2插入成功，此时查询T2会查询不到数据，但这个时间比较短，业务上往往是可以接受的； 3.不在一个分布式事务里，会出现数据不一致性  </p>
<p><strong>（3）线下异步冗余</strong><br>  添加一个bin log，然后调用服务进行T2表的数据插入<br>  优点：两次写操作解耦<br>  缺点：1.有延时，可能在T2中查询不到数据； 2.会出现数据不一致性问题  </p>
</blockquote>
<h2 id="四、“原子性事务”，正向表和反向表谁先操作？"><a href="#四、“原子性事务”，正向表和反向表谁先操作？" class="headerlink" title="四、“原子性事务”，正向表和反向表谁先操作？"></a>四、“原子性事务”，正向表和反向表谁先操作？</h2><blockquote>
<p>如果原子性被破坏，不一致出现，谁先做对业务的影响较小，就谁先执行</p>
</blockquote>
<h2 id="五、如何保证一致性？"><a href="#五、如何保证一致性？" class="headerlink" title="五、如何保证一致性？"></a>五、如何保证一致性？</h2><blockquote>
<p>在大数据、高并发、延迟敏感的业务中，并不能实时保证一致性，而是尽可能的发现数据不一致性，然后保证最终一致性。</p>
</blockquote>
<h2 id="六、如何保证一致性？"><a href="#六、如何保证一致性？" class="headerlink" title="六、如何保证一致性？"></a>六、如何保证一致性？</h2><blockquote>
<p> <strong>（1）全量数据扫描</strong><br>写一个离线程序，定时每天检查一次T1和T2表中数据是否一致，不一致的话进行补偿，使数据一致<br>优点：解耦<br>缺点：每天都需要大量检测，已经检测过的数据会重复检测，需要耗费的时间长，会导致数据不一致性的时间长</p>
<p> <strong>（2）增量日志扫</strong><br>服务插入T1或T2表后向T1日志或T2日志中写一条日志数据，然后写一个离线的程序，对日志进行检测，发现不一致则进行补偿，使数据一致<br>优点：1.不会重复检测数据； 2.检测周期缩短； 3.线上影响比较低<br>缺点：时效性还是不高  </p>
<p><strong>（3）实时消息对检测</strong><br> 增加一个消息队列，插入T1成功后就向消息队列中发送一条消息，插入T2d成功后，就向消息队列中发送一条消息，根据经验，5秒内能收到2条消息，如果未收到消息，则检测数据库数据是否一致<br> 缺点：复杂度高  </p>
</blockquote>
]]></content>
      <categories>
        <category>架构师训练营</category>
        <category>爆发期</category>
      </categories>
  </entry>
  <entry>
    <title>互联网公司部署方案</title>
    <url>/202010132041.html</url>
    <content><![CDATA[<p>&emsp;&emsp;但凡项目发布，都要考虑两个问题，一个是<strong>验证</strong>，一个是<strong>回滚</strong>。</p>
<p>&emsp;&emsp;<strong>验证</strong>就是说，你怎么确定你这次部署成功了？一般来说，要观察每台机器启动后处理请求时的日志，日志是否正常，是否有报错，一般日志正常、没有报错，那么就算是启动成功了，有时候也会让QA/PM做一个线上验证。</p>
<p>&emsp;&emsp;那么万一发布失败了呢？此时就得<strong>回滚</strong>，因为不同的上线是不一样的，有时候你仅仅是对代码做一些微调，大多数时候是针对新需求有上线，加了新的代码/接口，有时候是架构重构，实现机制和技术架构都变了，所以回滚可能也不太一样，比如，如果你是加了一些新的接口，结果上线失败了，此时新接口没人访问，直接代码回滚到旧版本重新部署就行了；如果你是做技术架构升级，此时失败了，可能很多请求已经处理失败，数据丢失，严重的时候会导致公司丢失订单，或者是数据写入了但是都错了，此时可能会采用回滚代码，或者清洗错乱数据的方式来回滚，总之，针对你的发布，你要考虑到失败之后的回滚方案，回滚代码，就得用旧版本的代码，然后重新在各个机器上依次部署，就算是一次回滚了，至于丢失了数据没有，要不要清洗数据，这个看情况来定。</p>
<h3 id="（1）滚动发布"><a href="#（1）滚动发布" class="headerlink" title="（1）滚动发布"></a>（1）滚动发布</h3><p>&emsp;&emsp;这是最常见的部署模式，一般就是说一个服务/系统都会部署在多台服务器上，部署的时候手动依次进行部署。比如每台服务器上放一个tomcat，每台机器依次停机tomcat，然后把新的代码放进去，再重新启动tomcat，各个服务器都这样做，这就是一种滚动发布。</p>
<p>&emsp;&emsp;中小型公司都会做自动化部署，自动化部署用的比较多的就是jenkins，因为jenkins是支持持续集成和持续交付的，简单来说就是你每天都提交代码，他每天都自动跑测试确保代码集成没问题，然后可能隔几天就把一个生产可用的小版本交付到线上。jenkins可以自动在多台机器上部署你的服务/系统，过程其实也是类似的，只不过把手动改成自动罢了。</p>
<p>&emsp;&emsp;中大型公司，一般发布系统都是自己研发的，你在上面指定一个服务，指定一个git仓库的代码分支，然后指定一个环境，指定一批机器，发布系统自动到git仓库拉取代码到本地，编译打包，然后在你指定环境的机器上，依次停止当前运行的进程，然后依次重启你新代码的服务进行。</p>
<p>&emsp;&emsp;以上这些都是典型的滚动发布。滚动发布的话，风险还是比较大的，因为一旦你用了自动化的滚动发布，那么发布系统会自动把你的所有机器都部署新版本的代码，这个时候中间很有可能会出现问题，导致大规模的异常和损失，所以现在一般中大型公司，都不会贸然用滚动发布模式。</p>
<h3 id="（2）灰度发布"><a href="#（2）灰度发布" class="headerlink" title="（2）灰度发布"></a>（2）灰度发布</h3><p>&emsp;&emsp;灰度发布就是说，不要上线就滚动全部发布到所有机器，一般就是会部署在比如1台机器上，采用新版本，然后切比如10%的流量过去，观察那10%的流量在1台机器上运行一段时间，比如运行几天时间，观察日志、异常、数据是否一切正常，如果验证发现全部都正常，那么此时就可以全量发布了，全量发布的时候就是采用滚动发布那种模式。</p>
<p>&emsp;&emsp;这个好处就是说，你先用10%以内的小流量放到灰度新版本的那台服务器上验证一段时间，感觉没问题了，才会全量部署，这么操作，即使有问题，也就10%以内的请求出现问题，损失不会太大，如果你公司体量特别大，灰度也可以是1%，甚至0.1%的流量。</p>
<p>&emsp;&emsp;如果灰度的时候有问题，那么立刻把10%以内的小流量切过去请求老版本代码部署的机器，灰度版本的机器立马就没有流量请求了，这个回滚速度是极快的。</p>
<p>&emsp;&emsp;通常灰度验证过后，全量发布都不会有太大的问题，基本上再出问题概率就很小了，所以现在中大型互联网公司一般都是灰度发布模式。</p>
<h3 id="（3）蓝绿部署"><a href="#（3）蓝绿部署" class="headerlink" title="（3）蓝绿部署"></a>（3）蓝绿部署</h3><p>&emsp;&emsp;蓝绿部署就是说，你得同时准备两个集群，一个集群放新版本代码，一个集群放老版本代码，然后新版本代码的集群准备好了过后，直接线上流量切到新版本集群上，跑一段时间来验证，如果发现有问题，回滚就是立马把流量切回老版本集群，回滚是很快速的。如果新版本集群运行一段时间感觉没问题了，此时就可以把老版本集群给下线了。</p>
<p>&emsp;&emsp;<strong>那么为什么有灰度发布了还要用蓝绿部署呢？</strong><br>&emsp;&emsp;灰度发布过后，还是要全量部署的，但是有时候，如果涉及到一些新的架构方案，或者是新的接口，10%以内的小流量可能没有办法暴露出线上的高并发问题，所以灰度验证没问题，结果全量部署还是有小概率会失败，此时全量发布用滚动发布的方式，逐步部署过去，很快会引发大规模的失败，此时回滚是很慢的，因为要一台一台逐步回滚。所以说，一般针对那种改动不太大的小版本，比如加一个接口，修改一些代码，修复几个bug，类似这种整体变动不太大的情况，建议使用灰度发布，因为这种一般灰度验证没问题，全量部署也不会有问题。但是如果涉及到那种很大规模的架构重构或者架构升级，比如数据存储架构升级，或者是技术架构整体改造，或者是代码大规模重构，类似这种场景，最好是用蓝绿部署，也就是说，完全部署一个新的集群，然后把较大的流量切过去，比如先切10%，再切50%，最后切到100%，让新集群承载100%的流量跑一段时间。过程中一旦有问题，立马流量全部切回老集群，这个回滚速度比灰度发布的全量部署回滚要快多了，因为仅仅是切流量而已，不需要重新部署。</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
        <category>技巧</category>
      </categories>
  </entry>
  <entry>
    <title>地下室手记</title>
    <url>/202012062053.html</url>
    <content><![CDATA[<p>第一次读陀思妥耶夫斯基，选的第一本是《地下室手记》，很小很薄的一本书，想做为读陀氏的入门。读完后，觉得甚是过瘾，以下简单写写读后感想。</p>
<p>主人公是一个年四十岁的公务员，得到远房亲戚遗留下的一笔遗产时，立刻辞职，蛰居在自己的小角落里。然后以地下室人的身份，以第一人称进行了一系列自身的剖析、诉说、与斗争，大段大段的内心独白，将自己思想的矛盾与精分展现的淋漓尽致。在看书的过程中，时刻看到自己的影子，随时跟着主人公一起精分，歇斯底里的咆哮、狂怒，然后又归于平静。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>微服务配置中心</title>
    <url>/202108241927.html</url>
    <content><![CDATA[<p>进行技术选型，首先应该是站在一个细化的角度，从各个方面去对比技术。</p>
<p>哪个技术最热门，用的人最多，那么就选用哪个技术。如果都很热门，用的人都很多，怎么选？<br>分场景，每种技术适合什么场景；<br>分公司，每种技术适合小公司还是大公司；</p>
<p>选型：Apollo、SpringCloudConfig、Nacos</p>
<p>apollo: 架构比较复杂，比较完善的，功能上也很完善，中小型公司并不一定要使用，中大型公司可以考虑使用。<br><a href="https://github.com/ctripcorp/apollo">https://github.com/ctripcorp/apollo</a></p>
<p>nacos: 作为一个服务注册中心本身就包含了配置中心的功能，没必要花很多时间再去部署一套apollo，完全可以满足很多中小型公司的配置中心的需求，哪怕是大公司也是可以用的，apollo确实用的公司很多，中大型公司都会去用apollo，而且他的功能也很完善。</p>
<p>spring cloud config: 如果用的不是spring cloud alibaba，用的是apring cloud netflix，可以配合那个技术栈，直接使用spring cloud提供的config项目作为配置中心就可以了，因为这是属于spring cloud原生技术栈里提供的。</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库事务</title>
    <url>/202011182114.html</url>
    <content><![CDATA[<h3 id="一、数据库事务的4个特性（ACID）"><a href="#一、数据库事务的4个特性（ACID）" class="headerlink" title="一、数据库事务的4个特性（ACID）"></a>一、数据库事务的4个特性（ACID）</h3><ul>
<li><p>原子性（Atomic）<br>  表示组成一个事务的多个数据库操作是一个不可分割的原子单元，只有所有的操作执行成功，整个事务才提交。事务中的任务一个数据库操作失败，已经执行的任何操作都必须撤销，让数据库返回到初始状态。</p>
</li>
<li><p>一致性（Consistency）<br>  事务操作成功后，数据所处的状态和它的业务规则是一致的，即数据不会被破坏。如从A账户转账100元到B账户，不管操作成功与否，A账户和B账户的存款总额是不变的。</p>
</li>
<li><p>隔离性（Isolation）<br>  在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对对方产生干扰。准备说，并非要求做到完全无干扰。数据库规定了多种事务隔离级别，不同的隔离级别对应不同的干扰程序，隔离级别越高，数据一致性越好，但并发性越弱。</p>
</li>
<li><p>持久性（Durabiliy）<br>  一旦事务提交成功后，事务中所有的数据操作都必须被持久化到数据库中。即使在提交事务后，数据库马上崩溃，在数据库重启时，也必须保证能够通过某种机制恢复数据。</p>
</li>
</ul>
<h3 id="二、事务的并发问题"><a href="#二、事务的并发问题" class="headerlink" title="二、事务的并发问题"></a>二、事务的并发问题</h3><ul>
<li><p><strong>脏读</strong><br>  A事务读取了B事务尚未提交的更改数据，B事务可能发生回滚，这时A事务读到的数据根本不存在，发生了脏读。   </p>
</li>
<li><p><strong>不可重复读</strong><br>  A事务读取了B事务已经提交的更改数据。  </p>
</li>
<li><p><strong>幻象读</strong><br>  A事务读取B事务提交的新增数据，这时A事务将出现幻象读。  幻象读一般发生在计算统计数据的事务中。</p>
</li>
<li><p><strong>第一类丢失更新</strong><br>  A事务撤销时，把已经提交的B事务的更新数据覆盖了。</p>
</li>
<li><p><strong>第二类丢失更新</strong><br>  A事务覆盖B事务已经提交的数据，造成B事务所做操作丢失。</p>
</li>
</ul>
<p><strong>注：</strong>幻象读和不可重复读是两个容易混淆的概念，前者是指读到了其他已经提交事务的新增数据，而后者是指读到了已经提交事务的更改数据（更改或删除）。为了避免这两种情况，采取的对策是不同的：防止读到更改数据，只需对操作的数据添加行级锁，阻止操作中的数据发生变化；而防止读到新增数据，则往往需要添加表级锁，即将整张表锁定，防止新增数据。  </p>
<h3 id="三、数据库锁机制"><a href="#三、数据库锁机制" class="headerlink" title="三、数据库锁机制"></a>三、数据库锁机制</h3><p>&emsp;&emsp;数据并发会引发很多问题，在一些场合下有些问题是允许的，但在另一些场合下可能是致命的。数据库通过锁机制解决并发访问的问题。按锁定的对象不同，一般可以分为<strong>表锁定</strong>和<strong>行锁定</strong>。前者对整张表进行锁定，后者对表中的特定行进行锁定。从并发事务锁定的关系上看，可以分为<strong>共享锁定</strong>和<strong>独占锁定</strong>。共享锁定会防止独占锁定，但允许其他的共享锁定；而独占锁定既防止其他的独占锁定，也防止其他的共享锁定。</p>
<h3 id="四、事务隔离级别"><a href="#四、事务隔离级别" class="headerlink" title="四、事务隔离级别"></a>四、事务隔离级别</h3><p>&emsp;&emsp;尽管数据库为用户提供了锁的DML操作方式，但直接使用锁管理是非常麻烦的，因为数据库为用户提供了自动锁机制。只要用户指定会话的事务隔离级别，数据库就会分析事务中的SQL语句，然后自动为事务操作的数据资源添加适合的锁。此外，数据库还会维护这些锁，当一个资源上的锁数目太多时，自动进行锁升级以提高系统的运行性能，这对用户来说是透明的。</p>
<p>&emsp;&emsp;ANSI/ISO SQL92标准定义了4个等级的事务隔离级别，在相同的数据环境下，使用相同的输入，执行相同的工作，根据不同的隔离级别，可能导致不同的结果。不同事务隔离级别能够解决的数据并发问题的能力是不同的。 </p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻象读</th>
<th align="center">第一类丢失更新</th>
<th align="center">第二类丢失更新</th>
</tr>
</thead>
<tbody><tr>
<td align="center">READ UNCOMMITED</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">READ COMITED</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">REPEATABLE READ</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">SERIALIZABLE</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>database</tag>
        <tag>tx</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/202108162129.html</url>
    <content><![CDATA[<p>死屋手记</p>
]]></content>
  </entry>
  <entry>
    <title>转正小记</title>
    <url>/202010102013.html</url>
    <content><![CDATA[<p>&emsp;&emsp;距离4月7号入职已过半年，今天终于要转正了，虽然现在比较佛系，但还是开心一下，毕竟转正后每月工资又多了些，现在就这点儿出息了，哈哈。</p>
<p>&emsp;&emsp;今天下午，生平第一次当着十几个人的面演讲ppt，足足讲了40分钟，真是紧张的要死，全程只顾着讲自己的，完全没有节奏，就像小学生背课文一样，哗啦啦一下将准备的东西都倒出来，也管不上听众的感受，自己也是身不由己，从没锻炼过，还有公众讲话恐惧症，不颤音不断片已经够好的了，以后还是要多多锻炼。</p>
<p>&emsp;&emsp;今晚可以睡个好觉了，这两天快被这个转正演讲折磨死了，从开始写ppt就一直处于紧张状态，跟打仗备战似的，时不时的进行演练一遍，昨晚重新改ppt加内容再过一遍弄到了1点，躺床上还是翻来覆去睡不着的在想着哪个点要怎样讲，好不容易睡着了梦里还是在和ppt拧巴，早上6点多醒了满脑子都是演讲的内容，脑子里再过一遍，公交地铁上书也没心看，一直在脑海里演练演讲的内容，上班后工作也不在状态也还在一直想着下午要怎么讲，中午吃饭和小伙伴说话都紧张的话都说不利索，吃完饭回来午睡又担心的睡不着手心开始冒汗，下午努力投入到工作中转移注意力，终于在5点开场进行了演讲，第一次第一次，激动、紧张，虽然全都是平时一起工作的同事，大家都很熟悉了，但心理就是这样不设防的塌陷，讲完之后如释重负，没有感动的想哭，只是想手舞足蹈，听着小伙伴们的评论，都是一个劲的夸赞，突然感觉很幸福，觉得自己在这个团队中能将自己的心理问题给治愈，能完善自己的人格缺陷，真真是太好了。最后还是丁总看的透澈，就是自己经历的太少了，踩的坑太少了，而又太脸皮子太薄，以后要多跳坑，有坑就跳，扛过了这波，剩下的就都不是事了。</p>
<p>&emsp;&emsp;生活总要有点仪式感，相信今天过后，自己可以朝着自己的展望脚踏实地的奋斗~</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>闲言碎语</title>
    <url>/202010181635.html</url>
    <content><![CDATA[<p>&emsp;&emsp;又是一个百无聊赖的周末，同往常一样，蜷缩在狭小的房间里过着与世隔绝的生活。一天没有出门，不知今天的天气如何，是晴天、阴天还是下雨天，一扇摆设似的窗户可以捕捉到天井漏下的天色、迷路的微风和一些房间传出的嘈杂的声音，如此看来，这窗户也倒不是一无是处，至少使得房间不显得那么闷和绝望。</p>
<p>&emsp;&emsp;上午窝在被窝里看了《黄金时代》这部电影，之前刚听到这电影名时以为是王小波的《黄金时代》被拍成电影了，后来了解到是讲萧红的平生，当时也没去翻出来看看，昨天看了b站的一个up主讲《呼兰河传》，再次提及了该电影，今天便找来了看看。看完有点儿小压抑，民国四大才女之一的萧红一生也是如此坎坷，在思想陈旧落后保守的年代，萧红逃婚与表哥私奔导致与家庭绝决，被抛弃后又被之前订婚的未婚夫抛弃，然后遇到了生命中最重要的男人萧军，共患难撑过了一段难捱的时光，但最后还是永远的分手了，后嫁给了端木蕻良，赶上日本侵华，颠沛流离，又身患重病，更不幸的是又被医生误诊喉咙有瘤，各种糟糕的事情糅杂在一起加速了萧红的生命走向了终点，年仅31岁。之前看过两遍萧红的《呼兰河传》，喜欢她写的呼兰河小镇的一些琐事，那是描述她童年的回忆，当时没有去了解萧红的一生，只是觉得能写出这样文字的作家很有才，应该也是顺顺当当的，但真没想到是这样的，看了这部电影后再去回味《呼兰河传》，萧红应该是经历了这么多坎坷后对童年生活的怀念和当时那种美好安静生活的思念吧。电影一头爷爷对萧红说，快快长大，长大就好了，但回过头来看，真的是长大就都好了么？这个应该都有体会的吧。</p>
<p>&emsp;&emsp;下午整理了下屋子，买了两个收纳箱，把书重新规整了一下，衣服收拾了一下，屋子也都弄了下，但发现还是有点儿乱乱的不知所措，就先这样吧，过不了几天就又乱成一团了。收拾了下心情，纠结了好久终于卸载了b站，以前老借着要在上面看学习视频为由留着，发现学习没学习多少，倒刷小视频上瘾了，实在受不了了就卸载得了，要看视频用电脑看，还能防止在床上葛优躺。之前卸载了知乎，现在没有也不刷了，最多偶尔有想知道的问题在电脑上找一下，今天又卸载了b站，可以省出时间来真正的多看书学习了，还有计划和目标没有安排没有实现，现在正是时候了。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>active-mq安装</title>
    <url>/202108222216.html</url>
    <content><![CDATA[<h4 id="一、安装步骤"><a href="#一、安装步骤" class="headerlink" title="一、安装步骤"></a>一、安装步骤</h4><h5 id="1-从activemq官网下载activemq"><a href="#1-从activemq官网下载activemq" class="headerlink" title="1.从activemq官网下载activemq"></a>1.从activemq官网下载activemq</h5><blockquote>
<p> <a href="http://activemq.apache.org/">http://activemq.apache.org/</a>  </p>
</blockquote>
<h5 id="2-将下载好的activemq的gz包上传到Linux服务器"><a href="#2-将下载好的activemq的gz包上传到Linux服务器" class="headerlink" title="2.将下载好的activemq的gz包上传到Linux服务器"></a>2.将下载好的activemq的gz包上传到Linux服务器</h5><h5 id="3-解压activemq包"><a href="#3-解压activemq包" class="headerlink" title="3.解压activemq包"></a>3.解压activemq包</h5><blockquote>
<pre><code># tar zvxf apache-activemq-5.16.2-bin.tar.gz </code></pre>
</blockquote>
<h5 id="4-启动activemq"><a href="#4-启动activemq" class="headerlink" title="4.启动activemq"></a>4.启动activemq</h5><blockquote>
</blockquote>
<pre><code>首先进入到mq的bin目录，然后通过./activemq start启动，以下表示启动成功！
# ./activemq start </code></pre>
<p><img src="/202108222216/activemq01.png" alt="启动activemq">  </p>
<h4 id="二、安装遇到的问题"><a href="#二、安装遇到的问题" class="headerlink" title="二、安装遇到的问题"></a>二、安装遇到的问题</h4><h5 id="1-查看activemq安装状态"><a href="#1-查看activemq安装状态" class="headerlink" title="1.查看activemq安装状态"></a>1.查看activemq安装状态</h5><blockquote>
<pre><code># ./activemq status</code></pre>
</blockquote>
<h5 id="2-查看activemq运行日志"><a href="#2-查看activemq运行日志" class="headerlink" title="2.查看activemq运行日志"></a>2.查看activemq运行日志</h5><blockquote>
<pre><code># ./activemq consile</code></pre>
</blockquote>
<h4 id="三、访问ActiveMQ页面"><a href="#三、访问ActiveMQ页面" class="headerlink" title="三、访问ActiveMQ页面"></a>三、访问ActiveMQ页面</h4><p>待ActiveMQ安装启动好，访问<a href="http://ip:8161/admin%EF%BC%8C%E7%99%BB%E5%BD%95%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E9%83%BD%E6%98%AFadmin(%E5%9C%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E5%8F%AF%E4%BF%AE%E6%94%B9)%EF%BC%8C%E8%BF%9B%E5%85%A5ActiveMQ%E7%9A%84%E4%B8%BB%E9%A1%B5%EF%BC%9A">http://ip:8161/admin，登录名和密码都是admin(在配置文件中可修改)，进入ActiveMQ的主页：</a><br><img src="/202108222216/activemq06.png" alt="activemq web页面"></p>
<p>页面访问不成功问题排查：<br><strong>1.Linux服务器的8161端口是否开放,如果没有开放，就开放8161端口</strong></p>
<blockquote>
<pre><code># 查看端口是否开放
# firewall-cmd --query-port=8161/tcp  
# 开放端口
# firewall-cmd --permanent --add-port=8161/tcp
# 重启防火墙
# firewall-cmd --reload</code></pre>
</blockquote>
<p><strong>2.查看日志，是否有存储大小设置过大，如果过大，修改配置文件</strong></p>
<blockquote>
</blockquote>
<pre><code># vim ./conf/activemq.xml</code></pre>
<p><img src="/202108222216/activemq07.png" alt="activemq.xml配置文件修改">  </p>
<p><strong>3.如果是用ip访问，而不是localhost或127.0.0.1访问，查看conf/jetty.xml配置文件，注释掉127.0.0.1这行</strong></p>
<blockquote>
</blockquote>
<pre><code># vim ./conf/jetty.xml</code></pre>
<p><img src="/202108222216/activemq08.png" alt="jetty.xml配置文件修改"></p>
<h4 id="四、ActiveMQ页面介绍"><a href="#四、ActiveMQ页面介绍" class="headerlink" title="四、ActiveMQ页面介绍"></a>四、ActiveMQ页面介绍</h4><h5 id="1-Queue消息队列页面"><a href="#1-Queue消息队列页面" class="headerlink" title="1.Queue消息队列页面"></a>1.Queue消息队列页面</h5><p><img src="/202108222216/activemq09.png" alt="jetty.xml配置文件修改">  </p>
<pre><code>Name: 消息队列名称
Number Of Pending Messages: 未被消费的消息数目
Number Of Consumers: 消费者的数量
Message Enqueued: 进入队列的消息；进入队列的总消息数目，包括已经被消费的和未被消费的。这个数量只增不减。
Message Dequeued: 已出队列的消息，即已被消费掉的消息数目。因为一个消息只会被成功消费一次，所以在Queues里它和进入队列的总数量相等，如果不等是因为有消息未被消费。</code></pre>
<h5 id="2-Topic主题页面"><a href="#2-Topic主题页面" class="headerlink" title="2.Topic主题页面"></a>2.Topic主题页面</h5><p><img src="/202108222216/activemq10.png" alt="jetty.xml配置文件修改">  </p>
<pre><code>Name: 主题名称
Number Of Pending Messages: 未被消费的消息数目
Number Of Consumers: 消费者的数量
Message Enqueued: 进入队列的消息；进入队列的总消息数目，包括已经被消费的和未被消费的。这个数量只增不减。
Message Dequeued: 已出队列的消息，即已被消费掉的消息数目。在Topics里，因为多消费者从而导致数量会比入队列数高。</code></pre>
<h5 id="3-Subscribers查看订阅者页面"><a href="#3-Subscribers查看订阅者页面" class="headerlink" title="3.Subscribers查看订阅者页面"></a>3.Subscribers查看订阅者页面</h5><p><img src="/202108222216/activemq11.png" alt="jetty.xml配置文件修改">  </p>
<pre><code>查看订阅者信息，只在Topics消息类型中这个页面才会有数据。</code></pre>
<h5 id="4-Connections查看连接数页面"><a href="#4-Connections查看连接数页面" class="headerlink" title="4.Connections查看连接数页面"></a>4.Connections查看连接数页面</h5><p><img src="/202108222216/activemq12.png" alt="jetty.xml配置文件修改">  </p>
<h4 id="五、ActiveMQ简单使用"><a href="#五、ActiveMQ简单使用" class="headerlink" title="五、ActiveMQ简单使用"></a>五、ActiveMQ简单使用</h4><blockquote>
<p>  <strong>引入jar包</strong> </p>
</blockquote>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
    &lt;artifactId&gt;activemq-core&lt;/artifactId&gt;
    &lt;version&gt;5.7.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<hr>
<blockquote>
<p><strong>1.点对点(P2P)模型</strong><br>&emsp;&emsp;点对点模型，采用的是队列（Queue）作为消息载体。在该模式中，一条消息只能被一个消费者消费，只能留在队列中，等待被消费，或者超时。例如：生产者生产了一个消息，只能由一个消费者进行消费，代码演示如下：</p>
</blockquote>
<blockquote>
</blockquote>
<p>Provider步骤：<br>    第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。<br>    第二步：使用ConnectionFactory对象创建一个Connection对象。<br>    第三步：开启连接，调用Connection对象的start方法。<br>    第四步：使用Connection对象创建一个Session对象。<br>    第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Queue对象。<br>    第六步：使用Session对象创建一个Producer对象。<br>    第七步：创建一个Message对象，创建一个TextMessage对象。<br>    第八步：使用Producer对象发送消息。<br>    第九步：关闭资源。 </p>
<blockquote>
</blockquote>
<pre><code>public class Provider &#123;
    private static String queue = &quot;demo&quot;;
    public static void main(String[] args) throws JMSException &#123;
        //第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号
        //brokerURL服务器的ip及端口号
        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(&quot;tcp://192.168.31.3:61616&quot;);
        //第二步：使用ConnectionFactory对象创建一个Connection对象。
        Connection connection = connectionFactory.createConnection();
        //第三步：开启连接，调用Connection对象的start方法。
        connection.start();
        //第四步：使用Connection对象创建一个Session对象。
        //第一个参数：是否开启事务。当为true时，开启事务，同时第二个参数可以忽略
        //第二个参数：消息的应答模式：1、自动应答；2、手动应答。当第一个参数为false时，才有意义。
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        //第五步：使用Session对象创建一个Destination对象（topic、queue）,此处创建一个Queue对象。
        //参数：队列名称
        Queue queue = session.createQueue(Provider.queue);
        //每六步：使用Session对象创建一个Producer对象。
        MessageProducer producer = session.createProducer(queue);
        for (int i = 0; i &lt; 10; i++) &#123;
            //第七步：创建一个Message对象，创建一个TextMessage对象。
            TextMessage textMessage = session.createTextMessage(&quot;消费者你好，我来了-&quot; + i);
            //第八步：使用Producer对象发送消息。
            producer.send(textMessage);
        &#125;
        System.out.println(&quot;----生产结束----&quot;);
        //第九步：关闭资源
        producer.close();
        session.close();
        connection.close();
    &#125;
&#125; </code></pre>
<blockquote>
</blockquote>
<p>Consumer步骤:<br>    第一步：创建一个ConnectionFactory对象。<br>    第二步：从ConnectionFactory对象中获得一个Connection对象。<br>    第三步：开启连接。调用Connection对象的start方法。<br>    第四步：使用Connection对象创建一个Session对象。<br>    第五步：使用Session对象创建一个Destination对象。和发送端保持一致queue，并且队列的名称一致。<br>    第六步：使用Session对象创建一个Consumer对象。<br>    第七步：接收消息。<br>    第八步：打印消息。<br>    第九步：关闭资源  </p>
<blockquote>
<pre><code>public class Comsoner &#123;
    private static String queue = &quot;demo&quot;;
    public static void main(String[] args) throws JMSException, IOException &#123;
        System.out.println(&quot;----消费结束----&quot;);
        //第一步：创建一个ConnectionFactory对象
        ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(&quot;tcp://192.168.31.3:61616&quot;);
        //第二步：从ConnectionFactory对象中获得一个Connection对象。
        Connection connection = factory.createConnection();
        //第三步：开启连接。调用Connection对象的start方法。
        connection.start();
        //第四步：使用Connection对象创建一个Session对象。
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        //第五步：使用Session对象创建一个Destination对象。和发送端保持一致queue，并且队列的名称一致。
        Queue queue = session.createQueue(Comsoner.queue);
        //第六步：使用Session对象创建一个Consumer对象。
        MessageConsumer consumer = session.createConsumer(queue);
        //第七步：接收消息
        consumer.setMessageListener(new MessageListener() &#123;
            public void onMessage(Message message) &#123;
                TextMessage textMessage = (TextMessage) message;
                try &#123;
                    String text = textMessage.getText();
                    System.out.println(text);
                &#125; catch (JMSException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;);
        //第八步：关闭资源
        consumer.close();
        session.close();
        connection.close();
    &#125;
&#125;</code></pre>
</blockquote>
<hr>
<blockquote>
<p><strong>2.发布/订阅（Pub/Sub）模型</strong><br>&emsp;&emsp;发布/订阅模型采用的是主题（Topic）作为消息通讯载体。该模式类似微信公众号的模式。发布者发布一条信息，然后将该信息传递给所有的订阅者。注意：订阅者想要接收到该消息，必须在该信息发布之前订阅。代码演示如下：</p>
</blockquote>
<blockquote>
</blockquote>
<p>Provider步骤：<br>    第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。<br>    第二步：使用ConnectionFactory对象创建一个Connection对象。<br>    第三步：开启连接，调用Connection对象的start方法。<br>    第四步：使用Connection对象创建一个Session对象。<br>    第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Queue对象。<br>    第六步：使用Session对象创建一个Producer对象。<br>    第七步：创建一个Message对象，创建一个TextMessage对象。<br>    第八步：使用Producer对象发送消息。<br>    第九步：关闭资源。 </p>
<blockquote>
</blockquote>
<pre><code>public class Comsoner &#123;
    private static String queue = &quot;topic&quot;;
    public static void main(String[] args) throws JMSException, IOException &#123;
        //第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。
        //brokerURL服务器的ip及端口号
        ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(&quot;tcp://192.168.31.3:61616&quot;);
        //第二步：使用ConnectionFactory对象创建一个Connection对象。
        Connection connection = factory.createConnection();
        //第三步：开启连接，调用Connection对象的start方法。
        connection.start();
        //第四步：使用Connection对象创建一个Session对象。
        //第一个参数：是否开启事务。true:开启，开启时第二个参数可以忽略
        //第二个参数：当第一个参数为false时，这个参数才有意义。消息的应答模式：1-自动应答；2-手动应答
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        //第五步：使用Session对象创建一个Destination对象。和发送端保持一致topic，并且话题和名称一致
        Topic topic = session.createTopic(queue);
        //第六步：使用Session对象创建一个Consumer对象
        MessageConsumer consumer = session.createConsumer(topic);
        //第七步：接收消息
        consumer.setMessageListener(new MessageListener() &#123;
            public void onMessage(Message message) &#123;
                TextMessage textMessage = (TextMessage) message;
                try &#123;
                    String text = textMessage.getText();
                    System.out.println(text);
                &#125; catch (JMSException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;);
        System.out.println(&quot;topic的消费端。。。。&quot;);
        //第八步：关闭资源
        consumer.close();
        session.close();
        connection.close();
    &#125;
&#125;</code></pre>
<blockquote>
</blockquote>
<p>Consumer步骤:<br>    第一步：创建一个ConnectionFactory对象。<br>    第二步：从ConnectionFactory对象中获得一个Connection对象。<br>    第三步：开启连接。调用Connection对象的start方法。<br>    第四步：使用Connection对象创建一个Session对象。<br>    第五步：使用Session对象创建一个Destination对象。和发送端保持一致queue，并且队列的名称一致。<br>    第六步：使用Session对象创建一个Consumer对象。<br>    第七步：接收消息。<br>    第八步：打印消息。<br>    第九步：关闭资源  </p>
<blockquote>
<pre><code>public class Comsoner &#123;
    private static String queue = &quot;demo&quot;;
    public static void main(String[] args) throws JMSException, IOException &#123;
        System.out.println(&quot;----消费结束----&quot;);
        //第一步：创建一个ConnectionFactory对象
        ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(&quot;tcp://192.168.31.3:61616&quot;);
        //第二步：从ConnectionFactory对象中获得一个Connection对象。
        Connection connection = factory.createConnection();
        //第三步：开启连接。调用Connection对象的start方法。
        connection.start();
        //第四步：使用Connection对象创建一个Session对象。
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        //第五步：使用Session对象创建一个Destination对象。和发送端保持一致queue，并且队列的名称一致。
        Queue queue = session.createQueue(Comsoner.queue);
        //第六步：使用Session对象创建一个Consumer对象。
        MessageConsumer consumer = session.createConsumer(queue);
        //第七步：接收消息
        consumer.setMessageListener(new MessageListener() &#123;
            public void onMessage(Message message) &#123;
                TextMessage textMessage = (TextMessage) message;
                try &#123;
                    String text = textMessage.getText();
                    System.out.println(text);
                &#125; catch (JMSException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;);
        //第八步：关闭资源
        consumer.close();
        session.close();
        connection.close();
    &#125;
&#125;</code></pre>
</blockquote>
<hr>
<blockquote>
<p><strong>3.两种模式对比</strong><br>1)由以上，我们可以总结出ActiveMQ的实现步骤：  </p>
</blockquote>
<ul>
<li>建立ConnectionFactory工厂对象，需要填入用户名、密码、连接地址  </li>
<li>通过ConnectionFactory对象创建一个Connection连接  </li>
<li>通过Connection对象创建Session会话  </li>
<li>通过Session对象创建Destination对象；在P2P的模式中，Destination被称作队列（Queue）,在Pub/Sub模式中，Destination被称作主题（Topic）  </li>
<li>通过Session对象创建消息的发送和接收对象  </li>
<li>发送消息  </li>
<li>关闭资源  </li>
</ul>
<blockquote>
</blockquote>
<p>2）可以看出，P2P模式和Pub/Sub模式，在实现上的区别是通过Session创建的Destination对象不一样，在P2P的模式中，Destination被称作队列（Queue）,在Pub/Sub模式中，Destination被称作主题（Topic）</p>
<h4 id="六、JMS消息可靠机制"><a href="#六、JMS消息可靠机制" class="headerlink" title="六、JMS消息可靠机制"></a>六、JMS消息可靠机制</h4><blockquote>
</blockquote>
<p>ActiveMQ消息签收机制：客户端成功接收一条消息的标志是一条消息被签收，成功应答。     </p>
<blockquote>
</blockquote>
<p>消息的签收情形分两种：<br>1、带事务的session。如果session带的事务，并且事务成功提交，则消息被自动签收。如果事务回滚，则消息会被再次传送。<br>2、不带事务的session。不带事务的session的签收方式，取决于session的配置。</p>
<blockquote>
</blockquote>
<p>ActiveMQ支持以下三种模式：<br>1、Session.AUTO_ACKNOWLEDGE 消息自动签收<br>2、Session.CLIENT_ACKNOWLEDGE客户端调用acknowledge方法手动签收。<br>&emsp;&emsp;textMessage.acknowledge(); //手动签收<br>3、Session.DUPS_OK_ACKNOWLEDGE不是必须签收。<br>&emsp;&emsp;消息可能会重复发送。在第二次重新传送消息的时候，消息只有在被确认之后，才认为已经被成功地消费了。消息的成功消费通常包含三个阶段：客户接收消息、客户处理消息和消息被确认。在事务性会话中，当一个事务被提交的时候，确认自动发生。在非事务性会话中，消息何时被确认取决于创建会话时的应答模式（acknowledgement mode)。该参数有以下三个可选值：<br>Number Of Consumers 消费者 这个 是消费者端的消费者数量<br>Numbwr Of Pending Messages等待消费的消息 这个是当前未出队列的数量。可以理解为总接收数-总出队列数<br>Messages Enqueued 进入队列的消息 进入队列的总数量，包括出队列的。这个数量只增不减<br>Messages Dequeued 出了队列的消息 可以理解为是消费者消费掉的数量。</p>
<h4 id="七、JMS可靠消息机制-持久话机制"><a href="#七、JMS可靠消息机制-持久话机制" class="headerlink" title="七、JMS可靠消息机制-持久话机制"></a>七、JMS可靠消息机制-持久话机制</h4><blockquote>
</blockquote>
<p>PERSISTENT：指示JMS provider持久保存消息，以保证消息不会因为JMS provider的失败而丢失<br>NON_PERSISTENT:不要求JMS provider持久保存消息<br>// 设置消息持久化 producer.setDeliveryMode(DeliveryMode.PERSISTENT);</p>
]]></content>
      <categories>
        <category>mq</category>
      </categories>
      <tags>
        <tag>mq</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo问题总结</title>
    <url>/202302041746.html</url>
    <content><![CDATA[<h2 id="1、执行hexo-deploy时，出现权限问题"><a href="#1、执行hexo-deploy时，出现权限问题" class="headerlink" title="1、执行hexo deploy时，出现权限问题"></a>1、执行hexo deploy时，出现权限问题</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Permission denied (publickey). </span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line">Please make sure you have the correct access rights and the repository exists.</span><br></pre></td></tr></table></figure>

<p>大致意思是说：没有权限，无法读取远程仓库。请确保你有正确的访问权限或者确认仓库的存在。</p>
<p><strong>解决方案</strong></p>
<p>简单粗暴的方法：直接删除已有的SSH文件然后重新设置并添加到github上。</p>
<p><strong>具体操作</strong></p>
<p>打开终端，输入：<font color="red"><code>ssh-keygen -t rsa -C &quot;你的邮箱地址&quot;</code></font> 这个命令会生成一个以你的邮箱为标签的SSH Key。</p>
<p>然后bash会显示：</p>
<p><font color="red"><code>Generating public/private rsa key pair.</code></font><br><font color="red"><code>Enter file in which to save the key (/c/Users/xxx/.ssh/id_rsa):</code></font> </p>
<p>直接回车，然后出现：</p>
<p><font color="red"><code>/c/Users/xxx/.ssh/id_rsa already exists.</code></font><br><font color="red"><code>Overwrite (y/n)?</code></font> </p>
<p>这说明你之前已经生成有SSH Key，此时你可以根据情况选择是否覆盖。</p>
<p>接下来将SSH Key添加到GitHub</p>
<ul>
<li><p>打开自己的GitHub，点击自己的头像找到Settings，然后在侧栏找到SSH and GPG keys，点击new SSH，复制刚才生成的id_rsa.pub中的所有内容到Key框中，在Title框中输入方便查找的名字保存即可。</p>
</li>
<li><p>打开终端，输入：<code>ssh -T git@github.com</code> 会在bash中显示：</p>
<p><code>Hi liyyao! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code><br><code>Connection to github.com closed.</code></p>
<p>看到此提示表示已经配置好了，再执行hexo deploy就不会有问题了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>SpringBoot学习</title>
    <url>/202302061623.html</url>
    <content><![CDATA[<h2 id="1、SpringBoot自动装配"><a href="#1、SpringBoot自动装配" class="headerlink" title="1、SpringBoot自动装配"></a>1、SpringBoot自动装配</h2><p>Spring Framework一直在致力于解决一个问题，就是如何让Bean的管理变得更简单，如何让开发者尽可能的少关注一些基础化的bean的配置，从而实现自动装配。所以，所谓的自动装配，实际上就是如何自动将Bean装载到IoC容器中来。</p>
<p>实际上在Spring 3.x版本中，Enable模块驱动注解的出现，已经有了一定的自动装配的雏形，而真正能够实现这一机制，还是在Spring 4.x版本中，Conditional条件注解的出现，接下来我们来看一下SpringBoot的自动装配是怎么一回事。</p>
<h3 id="1-1-自动装配例子"><a href="#1-1-自动装配例子" class="headerlink" title="1.1 自动装配例子"></a>1.1 自动装配例子</h3><p>我们在SpringBoot中使用redis时，只需要添加redis依赖，然后进行配置即可使用，如下面配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> </span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate&lt;String,String&gt;redisTemplate;</span><br></pre></td></tr></table></figure>

<p>按照上面配置好后，就可以使用RedisTemplate了，那么，为什么RedisTemplate可以被直接注入呢？它是什么时候加入到IoC容器的呢？这就是自动装配。自动装配可以使得classpath下依赖的包的相关的bean，被自动装载到Spring IoC容器中，那么这又是怎么做到的呢？</p>
<h3 id="1-2-EnableAutoConfiguration"><a href="#1-2-EnableAutoConfiguration" class="headerlink" title="1.2 EnableAutoConfiguration"></a>1.2 EnableAutoConfiguration</h3><p>EnableAutoConfiguration的主要作用其实就是帮助SpringBoot应用把所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器中。我们看EnableAutoConfiguration这个注解中，它的import是这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>但是从EnableAutoConfiguration上面的import注解来看，这里并不是引入另一个Configuration，而是一个<strong>ImportSelector</strong>，那么这个ImportSelector又是什么东西呢？可以看下Spring中@Import相关资料。了解了ImportSelector和ImportBeanDefinitionRegistrar后，对于EnableAutoConfiguration的理解就容易些了。</p>
<p>结合下面AutoConfigurationImportSelector类，其实EnableAutoConfiguration会帮助SpringBoot应用把所有符合@Configuration配置都加载到当前SpringBoot创建的IoC容器，而这里借助了Spring框架提供的一个工具类SpringFactoriesLoader的支持，以及用到了Spring提供的条件注解@Conditional，选择性的针对需要加载的bean进行条件过滤。</p>
<h3 id="1-3-AutoConfigurationImportSelector"><a href="#1-3-AutoConfigurationImportSelector" class="headerlink" title="1.3 AutoConfigurationImportSelector"></a>1.3 AutoConfigurationImportSelector</h3><p>Spring中的@Import注解可以配置三种不同的class：</p>
<ul>
<li>基于普通的bean或者带有@Configuration的bean进行静态注入</li>
<li>实现ImportSelector接口进行动态注入</li>
<li>实现ImportBeanDefinitionRegistrar接口进行动态注入</li>
</ul>
<p>看一下AutoConfigurationImportSelector类的继承关系</p>
<p><img src="/202302061623/springboot-000.png"></p>
<p>AutoConfigurationImportSelector类是实现了ImportSelector接口，所以它本质上是基于ImportSelector来实现bean的动态加载。ImportSelector接口中的selectImports方法返回的数组（类的全类名）都会被纳入到Spring容器中，那么猜想这里的实现原理也是一样的，定位到AutoConfigurationImportSelector这个类的selectImports方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">    	<span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取所有候选配置类EnableAutoConfiguration</span></span><br><span class="line">	AutoConfigurationEntry autoConfigurationEntry = 			getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">	<span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">    	<span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//获取元注解中的属性</span></span><br><span class="line">    AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">    <span class="comment">//使用SpringFactoriesLoader加载classpath路径下META-INF\spring.factories中</span></span><br><span class="line">    <span class="comment">//key=org.springframework.boot.autoconfigure.EnableAutoConfiguration对应的value</span></span><br><span class="line">    <span class="comment">//这里不同的版本可能会有些不同，我看2.7版本是放到META-INF\spring文件夹下，单独拎出来了</span></span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    <span class="comment">//去重</span></span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line">    <span class="comment">//应用exclusion属性</span></span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line">    <span class="comment">//过滤，检查候选配置类上的注解@ConditionalOnClass，如果要求的类不存在，则这个候选类会被过滤不被加载</span></span><br><span class="line">    configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">    <span class="comment">//广播事件</span></span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-SpringFactoriesLoader"><a href="#1-4-SpringFactoriesLoader" class="headerlink" title="1.4 SpringFactoriesLoader"></a>1.4 SpringFactoriesLoader</h3><p>这里简单分析一下SpringFactoriesLoader这个工具类的使用。它其实和Java中的SPI机制的原理是一样的，不过它比SPI更好的点在于不会一次性加载所有的类，而是根据key进行加载。SpringFactoriesLoader的作用是从classpath/META-INF/spring.factories文件中，根据key来加载对应的类到Spring IoC容器中。项目案例如下。</p>
<ul>
<li>创建外部项目jar</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;good good study, day day up&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;liyyao.com&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TestCore <span class="title">testCore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestCore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建另外一个工程（spring-boot）</li>
</ul>
<p>把前面的工程打成jar包，当前项目依赖该jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.liyyao.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SpringFactoriesLoaderDemo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过下面代码获取依赖包中的属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringFactoriesLoaderTestApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext ca = SpringApplication.run(SpringFactoriesLoaderTestApplication.class, args);</span><br><span class="line">        TestCore bean = ca.getBean(TestCore.class);</span><br><span class="line">        System.out.println(bean.study());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行会报错，因为TestCore并没有被Spring的IoC容器所加载，也就是没有被EnableAutoConfiguration导入。解决方案，在TestCore项目resources下新建文件夹META-INF，在文件夹下面新建spring.factories文件，文件中配置key为自动配置类EnableAutoConfiguration的全路径，value是配置类的全路径</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">com.liyyao.springboot.TestConfig</span></span><br></pre></td></tr></table></figure>

<p>重新打包，重新运行SpringFactoriesLoaderTestApplication这个类，可以发现我们编写的那个类就被加载进来了。</p>
<h3 id="1-5-SpringBoot中的条件过滤"><a href="#1-5-SpringBoot中的条件过滤" class="headerlink" title="1.5 SpringBoot中的条件过滤"></a>1.5 SpringBoot中的条件过滤</h3><p>在分析AutoConfigurationImportSelector的源码时，会先扫描spring-autoconfiguration-metadata.properties文件，最后在扫描spring.factories对应的类时，会结合前面的元数据进行过滤，为什么要过滤呢？因为很多的@Configuration其实是依托其他的框架来加载的，如果当前的classpath环境下没有相关联的依赖，则意味着这些类没必要进行加载，所以通过这种条件过滤可以有效的减少@Configuration类的数量从而降低SpringBoot的启动时间。</p>
<p>在1.4案例中，修改TestCore项目，在META-INF下增加配置文件，spring-autoconfigure-metadata.properties。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">com.liyyao.springboot.TestConfig.ConditionalOnClass</span>=<span class="string">com.liyyao.springboot.TestClass</span></span><br></pre></td></tr></table></figure>

<p><strong>格式：自动配置的类全名.条件=值</strong></p>
<p>上面这段配置意思就是如果当前的classpath下存在TestClass，则会对TestConfig这个Configuration进行加载。</p>
<p>沿用1.4案例中spring-boot工作的测试代码，直接运行main方法，发现原本能够被加载的TestCore类现在在IoC容器中找不到了。在当前工程中指定的包com.liyyao.springboot下创建一个TestClass以后，再运行代码，发现程序就能够正常运行了。</p>
<h3 id="1-6-手写Starter"><a href="#1-6-手写Starter" class="headerlink" title="1.6 手写Starter"></a>1.6 手写Starter</h3><p>通过手写Starter来加深对于自动装配的理解</p>
<h4 id="1-6-1-创建一个Maven项目，quick-starter"><a href="#1-6-1-创建一个Maven项目，quick-starter" class="headerlink" title="1.6.1 创建一个Maven项目，quick-starter"></a>1.6.1 创建一个Maven项目，quick-starter</h4><ul>
<li><strong>定义相关的依赖</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.79<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可选 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>定义Format接口</strong></li>
</ul>
<p>定义一个格式转换接口，并且定义两个实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FormatProcessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个格式化的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">String <span class="title">format</span><span class="params">(T object)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonFormatProcessor</span> <span class="keyword">implements</span> <span class="title">FormatProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">String <span class="title">format</span><span class="params">(T object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;JsonFormatProcessor: &quot;</span> + JSON.toJSON(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringFormatProcessor</span> <span class="keyword">implements</span> <span class="title">FormatProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">String <span class="title">format</span><span class="params">(T object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;StringFormatProcessor: &quot;</span> + object.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>定义配置类</strong></li>
</ul>
<p>首先定义格式化加载的Java配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormatAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConditionalOnMissingClass(&quot;com.alibaba.fastjson.JSON&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span>    <span class="comment">//优先加载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FormatProcessor <span class="title">stringFormatProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringFormatProcessor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConditionalOnClass(name = &quot;com.alibaba.fastjson.JSON&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FormatProcessor <span class="title">jsonFormatProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonFormatProcessor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>定义模板工具类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloFormatTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FormatProcessor formatProcessor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloFormatTemplate</span><span class="params">(FormatProcessor processor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.formatProcessor = processor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">String <span class="title">doFormat</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        builder.append(<span class="string">&quot;Execute format : &quot;</span>).append(<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">        builder.append(<span class="string">&quot;Object format result : &quot;</span>).append(formatProcessor.format(obj));</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>整合到SpringBoot中去的Java配置类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(FormatAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloFormatTemplate <span class="title">helloFormatTemplate</span><span class="params">(FormatProcessor formatProcessor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloFormatTemplate(formatProcessor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建spring.factories文件</li>
</ul>
<p>在resources下创建META-INF目录，再在其下创建spring.factories文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">com.liyyao.springboot.config.HelloAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<ul>
<li>install打包，然后就可以在SpringBoot项目中依赖该项目来操作了。</li>
</ul>
<h4 id="1-6-2-测试"><a href="#1-6-2-测试" class="headerlink" title="1.6.2 测试"></a>1.6.2 测试</h4><ul>
<li>在SpringBoot项目中引入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.liyyao.springboot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>FormatProject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在Controller中使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloFormatTemplate helloFormatTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/format&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">format</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">&quot;liyyao&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        <span class="keyword">return</span> helloFormatTemplate.doFormat(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>启动SpringBoot，在浏览器中访问<a href="http://localhost:8080/format%EF%BC%8C%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C">http://localhost:8080/format，即可看到输出结果</a></li>
</ul>
<p><img src="/202302061623/springboot-001.png"></p>
<h4 id="1-6-3-自定义Starter关联配置信息"><a href="#1-6-3-自定义Starter关联配置信息" class="headerlink" title="1.6.3 自定义Starter关联配置信息"></a>1.6.3 自定义Starter关联配置信息</h4><p>有些情况下我们需要用户在使用的时候动态的传递相关的配置信息，比如Redis的IP，端口等，这些信息显然是不能直接写到代码中的，这里我们就可以通过SpringBoot的配置类来实现。</p>
<ul>
<li>上面项目中导入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建对应的属性类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = HelloProperties.HELLO_FORMAT_PREFIX)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLO_FORMAT_PREFIX = <span class="string">&quot;liyyao.hello.format&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; info;</span><br><span class="line">    ...getter setter...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在Java配置类中关联</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(FormatAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(HelloProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloFormatTemplate <span class="title">helloFormatTemplate</span><span class="params">(HelloProperties helloProperties, FormatProcessor formatProcessor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloFormatTemplate(helloProperties, formatProcessor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>调整模板方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloFormatTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FormatProcessor formatProcessor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HelloProperties helloProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloFormatTemplate</span><span class="params">(HelloProperties helloProperties, FormatProcessor processor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.formatProcessor = processor;</span><br><span class="line">        <span class="keyword">this</span>.helloProperties = helloProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">String <span class="title">doFormat</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        builder.append(<span class="string">&quot;Execute format : &quot;</span>).append(<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">        builder.append(<span class="string">&quot;HelloProperties : &quot;</span>).append(formatProcessor.format(helloProperties.getInfo())).append(<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">        builder.append(<span class="string">&quot;Object format result : &quot;</span>).append(formatProcessor.format(obj));</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>增加提示</li>
</ul>
<p>在这个工程的META-INF/下创建一个additional-spring-configuration-metadata.json，这个是设置属性的提示类型</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;liyyao.hello.format.name&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;java.lang.String&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;账号信息&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;defaultValue&quot;</span>: <span class="string">&quot;root&quot;</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;liyyao.hello.format.age&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;java.lang.Integer&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;年龄&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;defaultValue&quot;</span>: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/202302061623/springboot-002.png"></p>
<ul>
<li>重新打包进行测试</li>
</ul>
<p>在SpringBoot项目中的properties文件中进行属性信息的配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">liyyao.hello.format.name</span>=<span class="string">liyyao</span></span><br><span class="line"><span class="meta">liyyao.hello.format.age</span>=<span class="string">25</span></span><br><span class="line"><span class="meta">liyyao.hello.format.info.key</span>=<span class="string">&quot;zhangsan&quot;</span></span><br><span class="line"><span class="meta">liyyao.hello.format.info.value</span>=<span class="string">&quot;haha&quot;</span></span><br></pre></td></tr></table></figure>

<p>重新启动SpringBoot项目进行访问</p>
<p><img src="/202302061623/springboot-003.png"></p>
]]></content>
      <categories>
        <category>springboot</category>
      </categories>
  </entry>
  <entry>
    <title>00-Spring注解编程发展过程</title>
    <url>/202302061853.html</url>
    <content><![CDATA[<h2 id="1、Spring注解编程发展过程"><a href="#1、Spring注解编程发展过程" class="headerlink" title="1、Spring注解编程发展过程"></a>1、Spring注解编程发展过程</h2><p><img src="/202302061853/spring-00.png"></p>
<h3 id="1-1-Spring-1-x"><a href="#1-1-Spring-1-x" class="headerlink" title="1.1 Spring 1.x"></a>1.1 Spring 1.x</h3><p>2004年3月24日，Spring1.0正式发布，提供了IoC，AOP及XML配置的方式。</p>
<p>在Spring1.x版本中提供的是纯XML配置的方式，也就是在该版本中我们必须要提供xml的配置文件，在该文件中我们通过<code>&lt;bean&gt;</code>标签来配置需要被IoC容器管理的bean。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.liyyao.demo.UserService&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext ac = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">&quot;classpath:applicationContext01.xml&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;ac.getBean(UserService.class) = &quot;</span> + ac.getBean(UserService.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Spring1.2版本的时候，提供了**<font color="red"><code>@Transaction</code></font>**（org.springframework.transaction.annotation）注解。简化了事件的操作。</p>
<h3 id="1-2-Spring-2-x"><a href="#1-2-Spring-2-x" class="headerlink" title="1.2 Spring 2.x"></a>1.2 Spring 2.x</h3><p>在2006年10月3日Spring2.0版本问世，在2.x版本中，比较重要的特点是增加了很多注解。</p>
<h4 id="1-2-1-Spring2-5之前"><a href="#1-2-1-Spring2-5之前" class="headerlink" title="1.2.1 Spring2.5之前"></a>1.2.1 Spring2.5之前</h4><p>在<strong>Spring 2.5之前</strong>新增的有<code>@Required</code> <code>@Repository</code> <code>@Aspect</code>，同时也扩展了XML的配置能力，提供了第三方的扩展标签，比如<code>&lt;dubbo&gt;</code>。</p>
<h5 id="1-2-1-Required"><a href="#1-2-1-Required" class="headerlink" title="1.2.1 @Required"></a>1.2.1 @Required</h5><p>如果你在某个java类的某个set方法上使用了该注解，那么该set方法对应的属性在xml配置文件中必须被设置，否则应付报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/202302061853/spring-01.png"></p>
<p>设置好属性后就没有错误提示了</p>
<p><img src="/202302061853/spring-02.png"></p>
<p>源码中可以看到@Required从2.0开始提供</p>
<p><img src="/202302061853/spring-03.png"></p>
<h5 id="1-2-2-Repository"><a href="#1-2-2-Repository" class="headerlink" title="1.2.2 @Repository"></a>1.2.2 @Repository</h5><p>@Repository对应数据访问层Bean，这个注解在Spring2.0版本就提供了</p>
<p><img src="/202302061853/spring-04.png"></p>
<h5 id="1-2-3-Aspect"><a href="#1-2-3-Aspect" class="headerlink" title="1.2.3 @Aspect"></a>1.2.3 @Aspect</h5><p>@Aspect是AOP相关的一个注解，用来标识配置类。</p>
<h4 id="1-2-2-Spring2-5之后"><a href="#1-2-2-Spring2-5之后" class="headerlink" title="1.2.2 Spring2.5之后"></a>1.2.2 Spring2.5之后</h4><p>在2007年11月19日，Spring更新到了2.5版本，新增了很多常用注解，大大的简化配置操作。</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Autowired</td>
<td>依赖注入</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>配置@Autowired注解使用</td>
</tr>
<tr>
<td>@Component</td>
<td>声明组件</td>
</tr>
<tr>
<td>@Service</td>
<td>声明业务层组件</td>
</tr>
<tr>
<td>@Controller</td>
<td>声明控制层组件</td>
</tr>
<tr>
<td>@RequestMapping</td>
<td>声明请求对应的处理方法</td>
</tr>
</tbody></table>
<p>在这些注解的作用下，我们可以不用在xml文件中去注册每个bean，这里我们只需要指定扫描路径，然后在对应的Bean头部添加相关的注解即可，这大大的简化了我们的配置及维护工作。案例如下。</p>
<ul>
<li>我们在配置文件中只需要配置扫描路径即可</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.liyyao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>持久层代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dao query...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>业务逻辑层代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.query();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>控制层代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService service;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.query();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring2.0.xml&quot;</span>);</span><br><span class="line">        UserController bean = ac.getBean(UserController.class);</span><br><span class="line">        bean.query();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然在Spring2.5版本提供了很多的注解，也大大的简化了开发，<strong>但是仍然没有摆脱XML配置驱动</strong>。</p>
<h3 id="1-3-Spring-3-x"><a href="#1-3-Spring-3-x" class="headerlink" title="1.3 Spring 3.x"></a>1.3 Spring 3.x</h3><p>在2009年12月16日发布了Spring3.0版本，这是一个注解编程发展的里程碑版本，在该版本中全面拥抱Java5，提供了<font color="red"><code>@Configuration</code></font>注解，目的就是去XML化，同时通过<font color="red"><code>@ImportResource</code></font>来实现Java配置类和XML配置的混合使，用来平稳过渡。</p>
<h4 id="1-3-1-Configuration"><a href="#1-3-1-Configuration" class="headerlink" title="1.3.1 @Configuration"></a>1.3.1 @Configuration</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Configuration</span> 标注的Java类，相当于application.xml配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Bean</span> 注解标注的方法就相当于&lt;bean&gt;&lt;/bean&gt;标签</span></span><br><span class="line"><span class="comment">     *  也是Spring3.0提供的注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserService <span class="title">userService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Spring3.1版本之前配置扫描路径我们还只能在XML配置文件中通过<code>component-scan</code>标签来实现，在3.1之前还不能够完全实现去XML配置，在3.1版本提供了一个<font color="red"><code>@ComponentScan</code></font>注解，该注解的作用是替换掉XML中的<code>component-scan</code>标签，是注解编程很大的进步，也是Spring实现无配置化的坚实基础。</p>
<h4 id="1-3-2-ComponentScan"><a href="#1-3-2-ComponentScan" class="headerlink" title="1.3.2 @ComponentScan"></a>1.3.2 @ComponentScan</h4><p>@ComponentScan的作用是指定扫描路径，用来替代在XML中的<code>&lt;component-scan&gt;</code>标签，默认的扫描路径是当前注解标注的类所在的包及其子包。</p>
<p>定义UserService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建对应的Java配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(JavaConfig.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;ac.getBean(UserService.class) = &quot;</span> + ac.getBean(UserService.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p><img src="/202302061853/spring-05.png"></p>
<p>当然也可以指定扫描的路径</p>
<p><img src="/202302061853/spring-06.png"></p>
<h4 id="1-3-3-Import"><a href="#1-3-3-Import" class="headerlink" title="1.3.3 @Import"></a>1.3.3 @Import</h4><p>@Import注解只能用在类上，作用是快速的将实例导入到Spring的IoC容器中，将实例导入到IoC容器中的方式有很多种，比如@Bean注解，@Import注解可以用于导入第三方包。具体的使用方式有三种。</p>
<h5 id="1-3-3-1-静态导入"><a href="#1-3-3-1-静态导入" class="headerlink" title="1.3.3.1 静态导入"></a>1.3.3.1 静态导入</h5><p>静态导入的方式是直接将我们需要导入到IoC容器中的对象类型直接添加进去即可。这种方式的好处是简单，直接，但是缺点就是如果要导入的类比较多，就不方便了，不够灵活。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(value = &#123;UserService.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(JavaConfig.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;ac.getBean(UserService.class) = &quot;</span> + ac.getBean(UserService.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/202302061853/spring-07.png"></p>
<h5 id="1-3-3-2-ImportSelector导入"><a href="#1-3-3-2-ImportSelector导入" class="headerlink" title="1.3.3.2 ImportSelector导入"></a>1.3.3.2 ImportSelector导入</h5><p>@Import注解中我们也可以添加一个实现了ImportSelector接口的类型，这时不会将该类型导入IoC容器中，而是会调用ImportSelector接口中定义的selectImports方法，将该方法的返回的字符串数组的类型添加到容器中。</p>
<p>定义两个业务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义ImportSelector接口的实现，方法返回的是需要添加到IoC容器中的对象对应的类型的类全路径的字符串数组，我们可以根据不同的业务需求导入不同的类型的类，会更加灵活些。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;Logger.class.getName(), Cache.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(value = &#123;MyImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(JavaConfig.class);</span><br><span class="line">        <span class="keyword">for</span> (String beanDefinitionName : ac.getBeanDefinitionNames()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;beanDefinitionName = &quot;</span> + beanDefinitionName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p><img src="/202302061853/spring-08.png"></p>
<h5 id="1-3-3-3-ImportBeanDefinitionRegistrar导入"><a href="#1-3-3-3-ImportBeanDefinitionRegistrar导入" class="headerlink" title="1.3.3.3 ImportBeanDefinitionRegistrar导入"></a>1.3.3.3 ImportBeanDefinitionRegistrar导入</h5><p>除了上面所介绍的ImportSelector方式灵活导入以外，还提供了<code>ImportBeanDefinitionRegistrar</code>接口，也可以实现Bean的导入，相比<code>ImportSelector</code>接口的方式，ImportBeanDefinitionRegistrar的方式是直接在定义的方法中提供了<code>BeanDefinitionRegistry</code>，自己在方法中实现注册。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将需要注册的对象封装为RootBeanDefinition对象</span></span><br><span class="line">        RootBeanDefinition cache = <span class="keyword">new</span> RootBeanDefinition(Cache.class);</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;cache&quot;</span>, cache);</span><br><span class="line"></span><br><span class="line">        RootBeanDefinition logger = <span class="keyword">new</span> RootBeanDefinition(Logger.class);</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;logger&quot;</span>, cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(value = &#123;MyImportBeanDefinitionRegistrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(JavaConfig.class);</span><br><span class="line">        <span class="keyword">for</span> (String beanDefinitionName : ac.getBeanDefinitionNames()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;beanDefinitionName = &quot;</span> + beanDefinitionName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p><img src="/202302061853/spring-09.png"></p>
<h4 id="1-3-4-EnableXXX"><a href="#1-3-4-EnableXXX" class="headerlink" title="1.3.4 @EnableXXX"></a>1.3.4 @EnableXXX</h4><p>@Enable模块驱动，其实是在系统中我们先开发好各个功能独立的模块，比如Web MVC模块，AspectJ代理模块，Caching模块等。</p>
<p><img src="/202302061853/spring-10.png"></p>
<p>案例说明，先定义好功能模块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个Java配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后定义@Enable注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义<span class="doctag">@Enable</span>注解</span></span><br><span class="line"><span class="comment"> * 在该注解中通过<span class="doctag">@Import</span>注解导入我们自定义的模块，使之生效。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(HelloWorldConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableHelloWorld &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载自定义模块</span></span><br><span class="line"><span class="meta">@EnableHelloWorld</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(JavaMain.class);</span><br><span class="line">        String helloWorld = ac.getBean(<span class="string">&quot;helloWorld&quot;</span>, String.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;helloWorld = &quot;</span> + helloWorld);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p><img src="/202302061853/spring-11.png"></p>
<h3 id="1-4-Spring-4-x"><a href="#1-4-Spring-4-x" class="headerlink" title="1.4 Spring 4.x"></a>1.4 Spring 4.x</h3><p>2013年11月1日更新的Spring4.0，完全支持Java8。这是一个注解完善的版本，提供的核心注解是@Conditional条件注解。@Conditional注解的作用是按照一定的条件进行判断，满足条件就给容器注册Bean实例。</p>
<p>@Conditional的定义行为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该注解可以在类和方法中使用</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Conditional &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 注解中添加的类型必须是实现了Condition接口的类型</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Class&lt;? extends Condition&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Condition是个接口，需要实现matches方法，返回true则注入bean，返回false则不注入。</p>
<p>案例讲解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 定义一个Condition接口的实现</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MyCondition implements Condition &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;</span><br><span class="line">        return false;   &#x2F;&#x2F;默认返回false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建Java配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 条件注解，添加的类型必须是实现了Condition接口的类型</span></span><br><span class="line"><span class="comment">     * MyCondition的matches方法返回true则注入，返回false则不注入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Conditional(MyCondition.class)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PersonService <span class="title">personService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PersonService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(JavaConfig.class);</span><br><span class="line">        <span class="keyword">for</span> (String beanDefinitionName : ac.getBeanDefinitionNames()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;beanDefinitionName = &quot;</span> + beanDefinitionName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<p><img src="/202302061853/spring-12.png"></p>
<p><img src="/202302061853/spring-13.png"></p>
<p>所以@Conditional的作用就是给我们提供了对象导入IoC容器的条件机制，这也是SpringBoot中的自动装配的核心关键。当然在4.x还提供了一些其他的注解，比如<code>@EventListener</code>作为ApplicationListener接口编程的第二选择，<code>@AliasFor</code>解除注解派生的时候冲突限制。@CrossOrigin作为浏览器跨域资源的解决方案等。</p>
<h3 id="1-5-Spring-5-x"><a href="#1-5-Spring-5-x" class="headerlink" title="1.5 Spring 5.x"></a>1.5 Spring 5.x</h3><p>在2017年9月28日，Spring来到了5.0版本。5.0同时也是SpringBoot2.0的底层。注解驱动的性能提升方面不是很明显。在SpringBoot应用场景中，大量使用@ComponentScan扫描，导致Spring模式的注解解析时间增大，因此，5.0版本引入**@Indexed**注解，为Spring模式添加索引。</p>
<p>当我们在项目中使用了<code>@Indexed</code>之后，编译打包的时候会在项目中自动生成<code>META-INF/spring.components</code>文件，当Spring应用上下文执行<code>ComponentScan</code>扫描时，<code>META-INF/spring.components</code>将会被<code>CandidateComponentsIndexLoader</code>读取并加载，转换为<code>CandidateComponentsIndex</code>对象，这样的话<code>@ComponentScan</code>不再扫描指定的package，而是读取<code>CandidateComponentsIndex</code>对象，从而达到提升性能的目的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-indexer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用@Indexed注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译打包后的结果</p>
<p><img src="/202302061853/spring-14.png"></p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
</search>
